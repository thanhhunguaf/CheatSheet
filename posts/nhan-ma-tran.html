<html>

<!-- Mirrored from thefullsnack.com/posts/nhan-ma-tran.html by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 12 May 2020 03:21:25 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf8" /><!-- /Added by HTTrack -->
<head>
<title>Các thuật toán nhân ma trận | Huy's Blog</title>
<meta charset="utf-8">
<meta http-equiv="content-type" content="text/html;"><meta name=viewport content="initial-scale=1.0 maximum-scale=1.0">
<meta property='og:image' content='../img/default.jpg'>
<link rel="apple-touch-icon" sizes="180x180" href="../apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="../favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="../favicon-16x16.png">
<link rel="manifest" href="../manifest.json">
<link rel="mask-icon" href="../safari-pinned-tab.svg" color="#5bbad5">
<meta name="theme-color" content="#ffffff">
<link href="../css/theme.dist.css" rel="stylesheet" type="text/css">
<link rel="stylesheet" href="../emoji/css/emoji.dist.css">
<link href="https://fonts.googleapis.com/css?family=Open+Sans:400,700|Space+Mono:400,700&amp;display=swap&amp;subset=vietnamese" rel="stylesheet">

<script async src="https://www.googletagmanager.com/gtag/js?id=UA-92158965-1"></script>
<script>
	       window.dataLayer = window.dataLayer || [];
	       function gtag(){dataLayer.push(arguments);}
	       gtag('js', new Date());

	       gtag('config', 'UA-92158965-1');
	      </script>
</head>
<body lang="en" class="post">
<div class="header lightweight-theme">
<a href="../index.html"><span class="avatar"></span></a>
</div>
<div class="container">
<div class="main">
<h1><span>Các thuật toán nhân ma trận</span></h1>
<div class="box-white padding-15">
<b>Update 03/01/2018:</b> Bài viết đã được cập nhật để sửa một số lỗi sai về cách ký hiệu kích thước ma trận trong phần ví dụ và thuật toán, cụ thể là:<br />
<ul>
<li>Ma trận $A$ kích thước $m \times n$ được sửa thành $n \times m$</li>
<li>Ma trận $B$ kích thước $n \times p$ được sửa thành $m \times p$</li>
<li>Ma trận $C$ kích thước $m \times p$ được sửa thành $n \times p$</li>
</ul>
Xin thành thật cáo lỗi với các bạn về sự nhầm lẫn này. Và xin cảm ơn các bạn @Jack Tăng và @Khanh Pham đã comment/nhắn tin góp ý.
</div>
<p>Ma trận và các phép toán liên quan tới nó là một phần rất quan trọng trong hầu hết mọi thuật toán liên quan đến số học.</p>
<p>Ở <a href="fibonacci-4m.html">bài trước</a>, chúng ta có đề cập tới việc ứng dụng phép nhân ma trận để tính số Fibonacci một cách hiệu quả. Vậy thuật toán nhân ma trận mà chúng ta sử dụng ở trong bài viết đã thực sự hiệu quả hay chưa?</p>
<div class='cover' style='background-image: url(img/matrixmul.jpg)'></div><div class='cover-holder'></div>
<p>Trong quá trình tìm hiểu để viết bài này thì mình phát hiện ra một điều khá là thú vị, đó là có rất nhiều thuật toán để thực hiện nhân ma trận, tuy nhiên ngành khoa học máy tính vẫn chưa tìm ra được câu trả lời cho câu hỏi: <strong>Đâu là thuật toán tối ưu để thực hiện phép nhân ma trận?</strong> <sup><a href="https://en.m.wikipedia.org/wiki/List_of_unsolved_problems_in_computer_science#Other_algorithmic_problems">[1]</a></sup></p>
<h2><a href="#định-nghĩa-phép-nhân-ma-trận" aria-hidden="true" class="anchor" id="định-nghĩa-phép-nhân-ma-trận"></a>Định nghĩa phép Nhân ma trận</h2>
<p>Nhắc lại một chút kiến thức toán học về phương pháp nhân 2 ma trận $A$ và $B$, điều kiện đầu tiên để có thể thực hiện phép nhân này là <strong>khi số cột của ma trận $A$ bằng số hàng của ma trận $B$</strong>.</p>
<p>Với $A$ là một ma trận có kích thước $n \times m$ và $B$ là một ma trận kích thước $m \times p$ thì tích của $A \times B$ sẽ là một ma trận $n \times p$ được tính bằng cách sau:</p>
<pre class='math'>$$
\left( \begin{array}{ccc}
a & b  \\
c & d  \end{array} \right) 
\times
\left( \begin{array}{ccc}
x \\
y
\end{array} \right)
=
\left( \begin{array}{ccc}
ax + by \\
cx + dy
\end{array} \right)
$$</pre>
<p>Hình sau mô tả cách tính một phần tử <code>AB[i][j]</code> của ma trận tích:</p>
<p><img src="img/matrix_mul_1.png" alt="" /></p>
<p>Một phần tử là tổng của phép nhân các phần tử trong một hàng của ma trận $A$ với các phần tử trong cột tương ứng trong ma trận $B$</p>
<pre class='math'>$$
[AB]_{i,j} = A_{i,1}B_{1,j} + A_{i,2}B_{2,j} + \ldots + A_{i,n}B_{n,j}
$$</pre>
<p>Hay viết cho gọn hơn như sau:</p>
<pre class='math'>$$
[AB]_{i,j} = \displaystyle\sum_{r=1}^{n} A_{i,r}B_{r,j}
$$</pre>
<div class="box-red skip" style="padding: 0 15px 0 15px;">
<p><b>Noob Question:</b> Cái dấu hình zích zắc $\sum$ kia là gì vậy???</p>
<p><b>Chửi trước:</b> Ôi trời, đây là cái dấu tính tổng mà cũng không biết à? Về học lại toán cấp 3 hay năm nhất ĐH gì đó đi nhé! Tốn thời gian bm!!<br />
<p><b>Đáp sau:</b> Cái dấu zích zắc đó là kí hiệu phép tính tổng, có thể hình dung kí hiệu này giống như một vòng lặp for trong thực hiện phép tính cộng, số $n$ ở trên đỉnh chỉ tổng số lần lặp cần thiết, số $r = 1$ ở dưới cho ta biết giá trị nào cần chạy trong vòng lặp for và bắt đầu chạy từ giá trị bao nhiêu. Biểu thức đi liền sau kí hiệu $\sum$ cho ta biết phép cộng các giá trị nào sẽ được thực hiện bên trong vòng lặp đó.
</div>
<p>Tiếp theo, hãy cùng xem chúng ta có những cách nào để implement thuật toán này trên máy tính.</p>
<h2><a href="#the-naive-algorithm" aria-hidden="true" class="anchor" id="the-naive-algorithm"></a>The naive algorithm</h2>
<p>Naive Algorithm là từ dùng để chỉ một thuật toán đơn giản nhất được suy luận một cách &quot;ngây thơ&quot; bằng cách xử lý thông thường, ví dụ như tìm kiếm tuần từ (sequential/linear search)</p>
<p>Trong trường hợp này, chúng ta thường implement thuật toán nhân ma trận bằng cách áp dụng chính xác công thức từ định nghĩa toán học của nó, sử dụng vòng lặp, như sau:</p>
<div class="box-green skip" style="padding-left: 10px; padding-right: 10px">
<p><b>Input:</b> Hai ma trận A kích thước $n \times m$ và B kích thước $m \times p$</p>
<p>
<b>1:</b> Khởi tạo ma trận C có kích thước $n \times p$ </br>
<b>2:</b> For i từ $1 \rightarrow n$:</br>
<b>3:</b> &emsp;For j từ $1 \rightarrow p$:</br>
<b>4:</b> &emsp;&emsp;Gán $sum = 0$<br />
<b>5:</b> &emsp;&emsp;For r từ $1 \rightarrow m$:<br />
<b>6:</b> &emsp;&emsp;&emsp;Gán $sum = sum + A_{i,r} \times B_{r,j}$<br />
<b>7:</b> &emsp;&emsp;Gán $C_{i,j} = sum$<br />
</p>
<p<b>Output:</b> Ma trận C kích thước $n \times p$</p>
</div>
<p>Tại sao lại gọi là naive algorithm (ngây thơ)? đó là vì nó rất dễ implement, chỉ cần đi theo lối suy nghĩ thông thường, bỏ qua hết mọi yếu tố như độ phức tạp, sự tối ưu...</p>
<p>Độ phức tạp của thuật toán trên là $\mathcal{O}(nmp)$, trong trường hợp tất cả các ma trận đều là ma trận vuông $n \times n$ thì độ phức tạp của thuật toán sẽ là $\mathcal{O}(n^{3})$</p>
<h2><a href="#chia-để-trị---thuật-toán-strassen" aria-hidden="true" class="anchor" id="chia-để-trị---thuật-toán-strassen"></a>Chia để trị - Thuật toán Strassen</h2>
<p>Vào năm 1969, Volker Strassen - lúc đó đang là sinh viên tại MIT - cho rằng $\mathcal{O}(n^{3})$ chưa phải là con số tối ưu cho phép nhân ma trận, và đề xuất một thuật toán mới có thời gian chạy chỉ nhanh hơn một chút nhưng về sau đã kéo theo rất nhiều nhà khoa học lao vào tiếp tục nghiên cứu và cho đến thời điểm bây giờ, đã có rất nhiều phương pháp mới được đưa ra như là thuật toán Coppersmith-Winograd (sẽ nói ở phần sau), hoặc các giải pháp tiếp cận bằng lập trình song song trên nhiều máy tính/nhiều core,... Điểm thú vị là Strassen nghĩ ra thuật toán này vì nó là bài tập trong một lớp mà ông đang học <sup><a href="http://www.procul.org/blog/2005/11/16/nhan-ma-trận-dft-va-ly-thuyết-biểu-diễn-nhom-1/">[2]</a></sup>.</p>
<p>Xét lại thuật toán naive ở phần trước, để tính một phần tử $C_{i,j}$ của ma trận tích $C$, ta phải thực hiện hai phép nhân và một phép cộng. Suy ra nếu $C$ là một ma trận vuông có kích thước $2 \times 2$, thì để tính bốn phần tử của $C$, đòi hỏi phải thực hiện $2 \times 2^{2} = 2^{3} = 8$ phép nhân và $(2 - 1) \times 2^{2} = 4$ phép cộng. Nếu $A$ và $B$ là những ma trận cấp $n$ (tức là các ma trận $n \times n$) thì chúng ta cần phải thực hiện $n^{3}$ phép nhân và $(n - 1) \times n^{2}$ phép cộng.</p>
<p>Ý tưởng thuật toán của Strassen <sup><a href="https://en.m.wikipedia.org/wiki/Strassen_algorithm">[3]</a></sup> là áp dụng chia để trị để giải quyết bài toán theo hướng của giải thuật cơ bản trên. Cụ thể là: <strong>với mỗi ma trận vuông A, B, C có kích thước $n \times n$, chúng ta chia chúng thành 4 ma trận con, và biểu diễn tích $A \times B = C$ theo các ma trận con đó</strong>:</p>
<p><img src="img/strassen.png" alt="" /></p>
<p>Trong đó:</p>
<pre class='math'>$$
\begin{align}
C_{1,1} & = A_{1,1}B_{1,1} + A_{1,2}B_{2,1} \\
C_{1,2} & = A_{1,1}B_{1,2} + A_{1,2}B_{2,2} \\
C_{2,1} & = A_{2,1}B_{1,1} + A_{2,2}B_{2,1} \\
C_{2,2} & = A_{2,1}B_{1,2} + A_{2,2}B_{2,2} 
\end{align}
$$</pre>
<p>Tuy nhiên với cách phân tích này thì chúng ta vẫn cần 8 phép nhân để tính ra ma trận $C$. Đây là phần quan trọng nhất của vấn đề.</p>
<p>Chúng ta định nghĩa ra các ma trận $M$ mới như sau:</p>
<pre class='math'>$$
\begin{align}
M_{1} & = (A_{1,1} + A_{2,2})(B_{1,1} + B_{2,2}) \\
M_{2} & = (A_{2,1} + A_{2,2}) B_{1,1} \\
M_{3} & = A_{1,1} (B_{1,2} - B_{2,2}) \\
M_{4} & = A_{2,2} (B_{2,1} - B_{1,1}) \\
M_{5} & = (A_{1,1} + A_{1,2}) B_{2,2} \\
M_{6} & = (A_{2,1} - A_{1,1})(B_{1,1} + B_{1,2}) \\
M_{7} & = (A_{1,2} - A_{2,2})(B_{2,1} + B_{2,2})
\end{align}
$$</pre>
<p>Và biểu diễn lại các phần tử của $C$ theo $M$ như sau:</p>
<pre class='math'>$$
\begin{align}
C_{1,1} & = M_{1} + M_{4} - M_{5} + M_{7} \\
C_{1,2} & = M_{3} + M_{5} \\ 
C_{2,1} & = M_{2} + M_{4} \\
C_{2,2} & = M_{1} - M_{2} + M_{3} + M_{6}
\end{align}
$$</pre>
<p>Bằng cách này, chúng ta chỉ cần 7 phép nhân (mỗi $M$ một phép nhân) thay vì 8 như phương pháp cũ.</p>
<p>Thực hiện đệ quy quá trình trên cho đến khi ma trận có cấp hai.</p>
<p>Độ phức tạp của thuật toán Strassen là $\mathcal{O}(n^{\log{7}}) \approx \mathcal{O}(n^{2.807})$</p>
<p>Đồ thị sau so sánh sự khác nhau về độ phức tạp của hai thuật toán vừa bàn:</p>
<p><img src="img/strassen_compare.jpg" alt="" /></p>
<h2><a href="#coppersmith-winograd-algorithm-và-các-thuật-toán-cải-tiến" aria-hidden="true" class="anchor" id="coppersmith-winograd-algorithm-và-các-thuật-toán-cải-tiến"></a>Coppersmith-Winograd Algorithm và các thuật toán cải tiến</h2>
<p>Dựa trên phát minh của Strassen, vào tháng 5/1987, hai nhà khoa học Don Coppersmith và Shmuel Winograd công bố bài báo <strong>Matrix Multiplication via Arithmetic Progression</strong> <sup><a href="https://www.cs.umd.edu/~gasarch/TOPICS/ramsey/matrixmult.pdf">[4]</a></sup> giới thiệu một phương pháp mới để tăng tốc độ nhân ma trận và cho biết độ phức tạp của thuật toán mà họ phát triển là $\mathcal{O}(n^{2.376})$ và được đánh giá là thuật toán nhân ma trận nhanh nhất tính tới thời điểm đó.</p>
<p><img src="img/cw_compare.jpg" alt="" /></p>
<p>Vào tháng 3/2013, A. M. Davie và A. J. Stothers công bố bài báo <strong>Improved bound for complexity of matrix multiplication</strong> <sup><a href="http://www.maths.ed.ac.uk/~sandy/a11164.pdf">[5]</a></sup> và cho biết họ đặt được con số $\mathcal{O}(n^{2.37369})$ khi cải tiến và khảo sát thuật toán của Coppersmith-Winograd.</p>
<p>Tháng 1/2014, François Le Gall công bố bài báo <strong>Powers of Tensors and Fast Matrix Multiplication</strong> <sup><a href="https://arxiv.org/abs/1401.7714">[6]</a></sup> tiếp tục phân tích thuật toán của hai nhà khoa học này và đạt được con số $\mathcal{O}(n^{2.3728639})$.</p>
<p>Vào tháng 7/2014, Virginia Vassilevska Williams thuộc đại học Standford công bố bài báo <strong>Multiplying matrices in $\mathcal{O}(n^{2.373})$ time</strong> <sup><a href="http://theory.stanford.edu/~virgi/matrixmult-f.pdf">[7]</a></sup> đưa ra phương pháp cải tiến thuật toán của Coppersmith-Winograd và công bố độ phức tạp là $\mathcal{O}(n^{2.372873})$.</p>
<h2><a href="#kết-luận" aria-hidden="true" class="anchor" id="kết-luận"></a>Kết luận</h2>
<p>Tổng kết lại, với các thuật toán hiện tại, chúng ta rút ra được bảng so sánh về độ phức tạp như sau:</p>
<table>
<thead>
<tr>
<th>Thuật toán</th>
<th>Input</th>
<th>Độ phức tạp</th>
</tr>
</thead>
<tbody>
<tr>
<td>Naive Algorithm</td>
<td>Ma trận vuông</td>
<td>$O(n^{3})$</td>
</tr>
<tr>
<td>Naive Algorithm</td>
<td>Ma trận bất kì</td>
<td>$O(nmp)$</td>
</tr>
<tr>
<td>Strassen Algorithm</td>
<td>Ma trận vuông</td>
<td>$O(n^{2.807})$</td>
</tr>
<tr>
<td>Coppersmith-Winograd Algorithm</td>
<td>Ma trận vuông</td>
<td>$O(n^{2.376})$</td>
</tr>
<tr>
<td>Các thuật toán CW cải tiến</td>
<td>Ma trận vuông</td>
<td>$O(n^{2.373})$</td>
</tr></tbody></table>
<p>Và các nhà khoa học vẫn đang miệt mài nghiên cứu để đưa con số này về $\mathcal{O}(n^{2})$</p>
<p><img src="img/matrix_all_compare.jpg" alt="" /></p>
<p>Theo một bình luận của giáo sư Ngô Quang Hưng trên Procul, thì các thuật toán của Strassen và Coppersmith-Winograd chỉ mang giá trị lý thuyết là chính, trong thực tế ít ai dùng cho các ma trận lớn vì hidden-constant quá lớn và implement phức tạp, dễ bị lỗi <sup><a href="http://www.procul.org/blog/2005/11/16/nhan-ma-trận-dft-va-ly-thuyết-biểu-diễn-nhom-1/#comment-11070">[8]</a></sup>.</p>
<div class='other-tags'><b>Tags:</b> <a class='topic-tag' href='../tags/algorithm.html'>algorithm</a><a class='topic-tag' href='../tags/math.html'>math</a><a class='topic-tag' href='../tags/performance.html'>performance</a></div>
<div class="related-posts" style="margin-top: 15px; border-bottom: 1px solid #eee;">
<p><i class="em em-sun_with_face"></i> Cảm ơn bạn đã theo dõi bài viết! các bạn có thể <a href="https://facebook.com/thefullsnackblog" target="_blank">follow mình trên Facebook</a> để đặt câu hỏi, hoặc nhận thông tin về các bài viết mới.</p>
</div>
<div class="comments">
<ul id="comment-list" class="comment-list"></ul>
<div id="login-box" class="login">
Bạn nghĩ như thế nào về bài viết này?<br /><button onclick="login()">Tham gia bình luận</button>
<div class="copyright">Chức năng này cần liên kết với tài khoản Google<br />Nếu không thích thì có thể comment <button onclick="goninja()">Nặc danh</button></div>
</div>
<div id="comment-box" class="comment-input">
<div class="avatar">
<img id="user-avatar" src="#" width="32" height="32" />
</div>
<div class="input">
<textarea id="comment-content" onkeydown="submitComment(event)" placeholder="Comment gõ vào đây :D"></textarea>
<span>Gõ xong nhấn <kbd>Ctrl</kbd> + <kbd>Enter</kbd> để gửi. Bạn không thể xóa comment sau khi gửi.</span>
<button id="comment-button" onclick="submitData()">Gửi</button>
</div>
</div>
</div>
</div>
</div>
<div class="footer lightweight-theme">
<p>you're free to use the content on this blog for whatever you want</p>
<p>Created with <i class="em em-coffee"></i> <a href="https://github.com/huytd/ristretto-rs">ristretto.rs</a></p>
</div>
<script src="../js/highlight.pack.js"></script>
<script>
        </script>
<script type="text/javascript" async src="../../cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJaxb198.js?config=TeX-MML-AM_CHTML"></script>
<script type="text/x-mathjax-config">
         MathJax.Hub.Config({
             tex2jax: {
                 inlineMath: [['$','$'], ['\\(','\\)']],
                 skipTags: ["script","noscript","style","textarea", "code"],
                 ignoreClass: "tex2jax_ignore|comment|comment-list|content"
             }
         });
        </script>
<script src="../js/toc.js"></script>
<script src="../../www.gstatic.com/firebasejs/3.8.0/firebase.js"></script>
<script>
         let postCommentURL = '../api/post/nhan-ma-tran.json';
         // Initialize Firebase
         var config = {
             apiKey: "AIzaSyA1PnIAlJJ-U6iQJMNnCOknBuziBqGMYcY",
             authDomain: "huys-blog-comment.firebaseapp.com",
             databaseURL: "https://huys-blog-comment.firebaseio.com",
             projectId: "huys-blog-comment",
             storageBucket: "huys-blog-comment.appspot.com",
             messagingSenderId: "317330376829"
         };

         var login = function() {
             window.auth.signInWithPopup(provider)
                   .then(function(result) {
                   }).catch(function(err) {
                   });
         };

         var goninja = function() {
             updateAuth({
                 displayName: "Không Tên",
                 photoURL: "https://thefullsnack.com/img/kaonashi.jpg"
             });
         };

         var updateAuth = function(user) {
             if (user) {
                 currentUser = user;
                 // Logged in
                 document.getElementById("login-box").style.display = "none";
                 document.getElementById("comment-box").style.display = "flex";
                 document.getElementById("user-avatar").setAttribute("src", user.photoURL + "?sz=32");
             } else {
                 // Not login yet
                 document.getElementById("comment-box").style.display = "none";
                 document.getElementById("login-box").style.display = "block";
             }
         };

         var encodeHTML = function(s) {
             return s.replace(/</g, '&lt;').replace(/"/g, '&quot;').replace(/>/g, '&gt;');
         };

         var saveNewComment = function(comment) {
             if (!currentUser) {
                 return;
             }
             var commentData = {
                 username: currentUser.displayName,
                 avatar: currentUser.photoURL,
                 post_time: ~~((new Date()).getTime() / 1000),
                 message: encodeHTML(comment)
             };

             fetch(postCommentURL, {
                 method: 'post',
                 headers: {
                     "Content-Type": "application/json"
                 },
                 body: JSON.stringify(commentData)
             }).then((result) => {
                 if (result.status === 200) {
                     addNewComment(commentData.username, commentData.avatar, commentData.post_time, commentData.message);
                 }
             });

             document.getElementById("comment-content").value = "";
         };

         function debounce(func, wait, immediate) {
             var timeout;
             return function() {
                 var context = this, args = arguments;
                 var later = function() {
                     timeout = null;
                     if (!immediate) func.apply(context, args);
                 };
                 var callNow = immediate && !timeout;
                 clearTimeout(timeout);
                 timeout = setTimeout(later, wait);
                 if (callNow) func.apply(context, args);
             };
         };

         var submitData = debounce(function() {
             var comment = document.getElementById("comment-content").value;
             if (comment.length) {
                 saveNewComment(comment);
             }
         }, 250);

         var submitComment = function(e) {
             var keyCode = e.which || e.keyCode;
             var ctrlCode = e.ctrlKey || e.metaKey;
             if (keyCode === 13 && ctrlCode) {
                 submitData();
             }
         };

         var filterNewlineInComment = function(t) {
             return t.replace(/\n/g, "<br/>");
         };

         var filterURLinComment = function(comment) {
             return comment.replace(/(https?:\/\/(?:www\.|(?!www))[a-zA-Z0-9][a-zA-Z0-9-]+[a-zA-Z0-9]\.[^\s]{2,}|www\.[a-zA-Z0-9][a-zA-Z0-9-]+[a-zA-Z0-9]\.[^\s]{2,}|https?:\/\/(?:www\.|(?!www))[a-zA-Z0-9]\.[^\s]{2,}|www\.[a-zA-Z0-9]\.[^\s]{2,})/g, "<a target='_blank' rel='noopener noreferrer' href='$1'>$1</a>");
         };

         var addNewComment = function(user, avatar, time, comment, first) {
             var commentFiltered = encodeHTML(comment);
             commentFiltered = filterNewlineInComment(filterURLinComment(commentFiltered));
             commentFiltered = commentFiltered.replace(/```/g, '');
             var d = new Date(time * 1000);
             var commentTime = d.toLocaleTimeString() + ' ' + d.toLocaleDateString();
             var anoNameClass = (avatar.indexOf('thefullsnack.com') !== -1) ? "grey" : "";
             var html = '<div class="avatar">' +
                        '   <img src="' + avatar + '?sz=32" width="32" height="32"/>' +
                        ' </div>' +
                        '<div class="comment">' +
                        '  <div class="metadata"><b class="' + anoNameClass + '">' + encodeHTML(user) + '</b> lúc <span>' + commentTime + '</span></div>' +
                        '  <div class="content tex2jax_ignore">' + commentFiltered
             '  </div>' +
                        '</div>';
             var li = document.createElement('li');
             li.innerHTML = html;
             if (!first) {
                 document.getElementById("comment-list").append(li);
             } else {
                 let elm = document.getElementById("comment-list");
                 elm.insertBefore(li, elm.firstChild);
             }
         };



         window.onload = function() {

             document.querySelectorAll("pre code").forEach(el => {
                 hljs.highlightBlock(el);
             });

             start_toc_module();

             firebase.initializeApp(config);
             window.provider = new firebase.auth.GoogleAuthProvider();
             window.auth = firebase.auth();
             window.currentUser = null;

             window.auth.onAuthStateChanged(function(user) {
                 updateAuth(user);
             });


             // Fetch comment and put to posts
             fetch(postCommentURL)
                 .then(res => res.json())
                 .then(data => {
                     if (data.comments) {
                         let comments = data.comments;
                         comments.sort((a, b) => a.post_time - b.post_time);
                         for (let i = 0; i < comments.length; i++) {
                             let cmt = comments[i];
                             addNewComment(cmt.username, cmt.avatar, cmt.post_time, cmt.message);
                         }
                     }
                 });
         };

         var toggle_wordwise = function(status) {
             var book = document.querySelector("book");
             var on = document.querySelector("#ww_on");
             var off = document.querySelector("#ww_off");
             if (!status) {
                 book.className = "off";
                 on.className = "btn-toggle";
                 off.className = "btn-toggle active";
             } else {
                 book.className = "";
                 on.className = "btn-toggle active";
                 off.className = "btn-toggle";
             }
         };
        </script>
</body>

<!-- Mirrored from thefullsnack.com/posts/nhan-ma-tran.html by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 12 May 2020 03:21:49 GMT -->
</html>
