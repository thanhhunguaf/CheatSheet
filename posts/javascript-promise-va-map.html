<html>

<!-- Mirrored from thefullsnack.com/posts/javascript-promise-va-map.html by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 12 May 2020 03:19:24 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf8" /><!-- /Added by HTTrack -->
<head>
<title>Promise, Async/Await và Map/Reduce | Huy's Blog</title>
<meta charset="utf-8">
<meta http-equiv="content-type" content="text/html;"><meta name=viewport content="initial-scale=1.0 maximum-scale=1.0">
<meta property='og:image' content='../img/default.jpg'>
<link rel="apple-touch-icon" sizes="180x180" href="../apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="../favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="../favicon-16x16.png">
<link rel="manifest" href="../manifest.json">
<link rel="mask-icon" href="../safari-pinned-tab.svg" color="#5bbad5">
<meta name="theme-color" content="#ffffff">
<link href="../css/theme.dist.css" rel="stylesheet" type="text/css">
<link rel="stylesheet" href="../emoji/css/emoji.dist.css">
<link href="https://fonts.googleapis.com/css?family=Open+Sans:400,700|Space+Mono:400,700&amp;display=swap&amp;subset=vietnamese" rel="stylesheet">

<script async src="https://www.googletagmanager.com/gtag/js?id=UA-92158965-1"></script>
<script>
	       window.dataLayer = window.dataLayer || [];
	       function gtag(){dataLayer.push(arguments);}
	       gtag('js', new Date());

	       gtag('config', 'UA-92158965-1');
	      </script>
</head>
<body lang="en" class="post">
<div class="header lightweight-theme">
<a href="../index.html"><span class="avatar"></span></a>
</div>
<div class="container">
<div class="main">
<h1><span>Promise, Async/Await và Map/Reduce</span></h1>
<p>Có một cái sai mà người ta thường hay mắc phải khi làm việc với <code>async/await</code>, đó là khi kết hợp nó với các hàm <code>Array.map/Array.reduce</code>, họ hiểu sai tác dụng của <code>async/await</code>, dẫn tới việc kết quả trả về không như ý.</p>
<p>Giả sử ta có hàm <code>parseUrl(&lt;url&gt;)</code> nhận vào một chuỗi (là địa chỉ của một RSS feed), và trả về danh sách các item có trong RSS feed đó, mà ở đây chúng ta biểu diễn bằng một mảng <code>[article]</code>, kết quả trả về thông qua <code>Promise</code>, nội dung hàm này như nào thì không ảnh hưởng nhiều tới bài viết, nên chả cần ghi ra làm gì:</p>
<pre><code class="language-javascript">// parseUrl :: string -&gt; Promise [article]
</code></pre>
<p>Khi sử dụng <code>await</code>, ta có thể lấy kết quả của <code>Promise</code> đó như thế này, có thể minh họa bằng sơ đồ:</p>
<pre><code class="language-javascript">await parseUrl(&quot;https://thefullsnack.com/rss.xml&quot;);
</code></pre>
<p><img src="img/javascript-promise-parseurl.png" alt="" /></p>
<p>Tiếp theo, là hàm <code>getArticles([urls])</code> nhận vào một mảng nhiều RSS feed URL, và trả về nhiều mảng chứa danh sách các item tương ứng với từng feed, theo như hiểu biết về cách làm việc với <code>Promise</code> thông qua hàm <code>await</code> như trên, mà <code>await</code> chỉ sử dụng được bên trong các hàm <code>async</code>, vậy thì thêm <code>async</code> vào, ta có thể dễ dàng implement như sau:</p>
<pre><code class="language-javascript">// getArticles :: [string] -&gt; [[article]]
async function getArticles(sources) {
    return await sources.map(async (url) =&gt; {
        return await parseUrl(url);
    });
}
</code></pre>
<p>Chúng ta expect hàm <code>getArticles</code> hoạt động theo sơ đồ bên dưới:</p>
<p><img src="img/javascript-promise-getarticles.png" alt="" /></p>
<p>Tuy nhiên, khi chạy, thì hàm trên không trả về kết quả như mong đợi:</p>
<pre><code class="language-javascript">getArticles([
    &quot;https://thefullsnack.com/rss.xml&quot;,
    &quot;https://news.ycombinator.com/rss&quot;
])

// Output:

[ Promise { [ [Object] ] },
  Promise { [ [Object] ] } ]
</code></pre>
<p>Chúng ta <strong>tưởng</strong> rằng, sử dụng lệnh <code>await</code> sẽ giúp trả về kết quả được <code>resolved</code> của một <code>Promise</code>, mà cụ thể ở đây bên trong hàm <code>source.map()</code>, chúng ta có thể nhận được một mảng chứa kết quả của các promise <code>parseUrl</code>. Nhưng trong trường hợp này, kết quả trả về lại là các <code>Promises</code>, vậy chúng ta đã làm sai ở chỗ nào?</p>
<hr />
<p>Hãy xem một hàm <code>async</code> hoạt động ra sao:</p>
<pre><code class="language-javascript">async function increase(a) {
    return a + 1;
}

increase(1);

// Output:

Promise { 2 }
</code></pre>
<p>Hàm <code>async</code> luôn trả về một <code>Promise</code>, viết type singature theo kiểu mấy ngôn ngữ functional là:</p>
<pre><code class="language-javascript">// async increase :: number -&gt; Promise number
</code></pre>
<p><img src="img/javascript-promise-async.png" alt="" /></p>
<p>Còn từ khóa <code>await</code> thì có tác dụng dừng việc thực thi code lại và chờ lấy trực tiếp giá trị trả về trong một <code>Promise</code>:</p>
<pre><code class="language-javascript">// await Promise number -&gt; number
let two = await increase(1);
// two = 2
</code></pre>
<p><img src="img/javascript-promise-await.png" alt="" /></p>
<p>Nếu không dùng <code>await</code> thì ta phải dùng <code>.then()</code>, là cách truyền thống để nhận giá trị trả về của một <code>Promise</code>, giá trị trả về chỉ có thể sử dụng được trong scope (phạm vi) của <code>.then()</code>, và không biết sử dụng nó trực tiếp ở scope hiện tại như thế nào luôn.</p>
<pre><code class="language-javascript">let two = increase(1).then(n =&gt; {
   // n = 2
   ...
})
// two = Promise
</code></pre>
<hr />
<p>Quay trở lại ví dụ đầu bài, hãy cùng xem lại hàm <code>getArticles</code> trả về kết quả như thế nào. Chúng ta sẽ đi từ trong ra ngoài.</p>
<pre><code class="language-javascript">async function getArticles(sources) {
    return await sources.map(async (url) =&gt; {
        return await parseUrl(url);
    });
}
</code></pre>
<p>Đầu tiên là hàm xử lý dữ liệu trong khối lệnh <code>sources.map()</code>:</p>
<pre><code class="language-javascript">// async f :: string -&gt; Promise [article]
async (url) =&gt; {
    return await parseUrl(url);
}
</code></pre>
<p>Ngay tại đây chúng ta thấy, hàm callback của <code>sources.map()</code> trả về một <code>Promise</code> chứ không phải là một mảng các <code>article</code> như dự tính ban đầu.</p>
<div class="mute">
■ <i class='em em-chicken'></i> Mặc dù chúng ta sử dụng await để lấy kết quả trả về từ parseUrl() (vốn là một Promise), tuy nhiên vì nằm trong một hàm async, kết quả này rốt cuộc cũng bị wrap lại vào bên trong một Promise. <i class='em em-joy'></i>
</div>
<p>Điều này dẫn đến việc, kết quả của câu lệnh <code>map</code> là một mảng các <code>Promises</code>, thay vì là mảng của các mảng <code>[article]</code> như ta nghĩ.</p>
<p><img src="img/javascript-promise-map.png" alt="" /></p>
<p>Và kết quả là hàm <code>getArticles()</code> trả về một mảng các <code>Promises</code>, và mỗi một <code>Promise</code> trong mảng này lại chứa các <code>[article]</code> của chúng ta:</p>
<p><img src="img/javascript-promise-real-getarticles.png" alt="" /></p>
<p>Vậy nên, cách để giải quyết vấn đề trên là, sử dụng <code>Promise.all()</code> để lấy toàn bộ kết quả trả về từ các <code>Promise</code> có trong <code>sources.map()</code>, sau đó mới đưa ra cho hàm <code>getArticles()</code>:</p>
<pre><code class="language-javascript">async function getArticles(sources) {
    let promises = sources.map(async (url) =&gt; {
        return await parseUrl(url);
    });
    return await Promise.all(promises);
}

let url = await getArticles([
    &quot;https://thefullsnack.com/rss.xml&quot;,
    &quot;https://news.ycombinator.com/rss&quot;
])

// Output:

[ [ { title: 'Giấy với bút',
      link:  'https://thefullsnack.com/posts/paper-and-pen.html' },
    { title: 'Vài ghi chép về V8 và Garbage Collection',
      link:  'https://thefullsnack.com/posts/javascript-v8-notes.html' },
    ...
  ],
  [ { title: 'Elon Musk Accused by SEC of Misleading Investors in August Tweet',
      link:  'https://news.ycombinator.com/item?id=18088099' },
    { title: 'People can die from giving up the fight',
      link:  'https://news.ycombinator.com/item?id=18083509' },
    ...
  ] ]
</code></pre>
<hr />
<p>Bài học rút ra ở đây là gì? Đó là, luôn luôn đọc kĩ tài liệu trước khi cắm đầu sử dụng, và quan trọng nhất là không được đoán mò <i class='em em-smirk'></i>, <code>async/await</code>, cũng giống như mọi khái niệm khác trong JavaScript, luôn cực kì rắc rối và khó hiểu cho tới chừng nào chúng ta... hiểu nó.</p>
<p>Mình biết điều này vì chính mình cũng đã lười đọc tài liệu, dẫn đến làm sai, nên mới có bài viết này <i class='em em-joy'></i></p>
 <div class='other-tags'><b>Tags:</b> <a class='topic-tag' href='../tags/javascript.html'>javascript</a></div>
<div class="related-posts" style="margin-top: 15px; border-bottom: 1px solid #eee;">
<p><i class="em em-sun_with_face"></i> Cảm ơn bạn đã theo dõi bài viết! các bạn có thể <a href="https://facebook.com/thefullsnackblog" target="_blank">follow mình trên Facebook</a> để đặt câu hỏi, hoặc nhận thông tin về các bài viết mới.</p>
</div>
<div class="comments">
<ul id="comment-list" class="comment-list"></ul>
<div id="login-box" class="login">
Bạn nghĩ như thế nào về bài viết này?<br /><button onclick="login()">Tham gia bình luận</button>
<div class="copyright">Chức năng này cần liên kết với tài khoản Google<br />Nếu không thích thì có thể comment <button onclick="goninja()">Nặc danh</button></div>
</div>
<div id="comment-box" class="comment-input">
<div class="avatar">
<img id="user-avatar" src="#" width="32" height="32" />
</div>
<div class="input">
<textarea id="comment-content" onkeydown="submitComment(event)" placeholder="Comment gõ vào đây :D"></textarea>
<span>Gõ xong nhấn <kbd>Ctrl</kbd> + <kbd>Enter</kbd> để gửi. Bạn không thể xóa comment sau khi gửi.</span>
<button id="comment-button" onclick="submitData()">Gửi</button>
</div>
</div>
</div>
</div>
</div>
<div class="footer lightweight-theme">
<p>you're free to use the content on this blog for whatever you want</p>
<p>Created with <i class="em em-coffee"></i> <a href="https://github.com/huytd/ristretto-rs">ristretto.rs</a></p>
</div>
<script src="../js/highlight.pack.js"></script>
<script>
        </script>
<script type="text/javascript" async src="../../cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJaxb198.js?config=TeX-MML-AM_CHTML"></script>
<script type="text/x-mathjax-config">
         MathJax.Hub.Config({
             tex2jax: {
                 inlineMath: [['$','$'], ['\\(','\\)']],
                 skipTags: ["script","noscript","style","textarea", "code"],
                 ignoreClass: "tex2jax_ignore|comment|comment-list|content"
             }
         });
        </script>
<script src="../js/toc.js"></script>
<script src="../../www.gstatic.com/firebasejs/3.8.0/firebase.js"></script>
<script>
         let postCommentURL = '../api/post/javascript-promise-va-map.json';
         // Initialize Firebase
         var config = {
             apiKey: "AIzaSyA1PnIAlJJ-U6iQJMNnCOknBuziBqGMYcY",
             authDomain: "huys-blog-comment.firebaseapp.com",
             databaseURL: "https://huys-blog-comment.firebaseio.com",
             projectId: "huys-blog-comment",
             storageBucket: "huys-blog-comment.appspot.com",
             messagingSenderId: "317330376829"
         };

         var login = function() {
             window.auth.signInWithPopup(provider)
                   .then(function(result) {
                   }).catch(function(err) {
                   });
         };

         var goninja = function() {
             updateAuth({
                 displayName: "Không Tên",
                 photoURL: "https://thefullsnack.com/img/kaonashi.jpg"
             });
         };

         var updateAuth = function(user) {
             if (user) {
                 currentUser = user;
                 // Logged in
                 document.getElementById("login-box").style.display = "none";
                 document.getElementById("comment-box").style.display = "flex";
                 document.getElementById("user-avatar").setAttribute("src", user.photoURL + "?sz=32");
             } else {
                 // Not login yet
                 document.getElementById("comment-box").style.display = "none";
                 document.getElementById("login-box").style.display = "block";
             }
         };

         var encodeHTML = function(s) {
             return s.replace(/</g, '&lt;').replace(/"/g, '&quot;').replace(/>/g, '&gt;');
         };

         var saveNewComment = function(comment) {
             if (!currentUser) {
                 return;
             }
             var commentData = {
                 username: currentUser.displayName,
                 avatar: currentUser.photoURL,
                 post_time: ~~((new Date()).getTime() / 1000),
                 message: encodeHTML(comment)
             };

             fetch(postCommentURL, {
                 method: 'post',
                 headers: {
                     "Content-Type": "application/json"
                 },
                 body: JSON.stringify(commentData)
             }).then((result) => {
                 if (result.status === 200) {
                     addNewComment(commentData.username, commentData.avatar, commentData.post_time, commentData.message);
                 }
             });

             document.getElementById("comment-content").value = "";
         };

         function debounce(func, wait, immediate) {
             var timeout;
             return function() {
                 var context = this, args = arguments;
                 var later = function() {
                     timeout = null;
                     if (!immediate) func.apply(context, args);
                 };
                 var callNow = immediate && !timeout;
                 clearTimeout(timeout);
                 timeout = setTimeout(later, wait);
                 if (callNow) func.apply(context, args);
             };
         };

         var submitData = debounce(function() {
             var comment = document.getElementById("comment-content").value;
             if (comment.length) {
                 saveNewComment(comment);
             }
         }, 250);

         var submitComment = function(e) {
             var keyCode = e.which || e.keyCode;
             var ctrlCode = e.ctrlKey || e.metaKey;
             if (keyCode === 13 && ctrlCode) {
                 submitData();
             }
         };

         var filterNewlineInComment = function(t) {
             return t.replace(/\n/g, "<br/>");
         };

         var filterURLinComment = function(comment) {
             return comment.replace(/(https?:\/\/(?:www\.|(?!www))[a-zA-Z0-9][a-zA-Z0-9-]+[a-zA-Z0-9]\.[^\s]{2,}|www\.[a-zA-Z0-9][a-zA-Z0-9-]+[a-zA-Z0-9]\.[^\s]{2,}|https?:\/\/(?:www\.|(?!www))[a-zA-Z0-9]\.[^\s]{2,}|www\.[a-zA-Z0-9]\.[^\s]{2,})/g, "<a target='_blank' rel='noopener noreferrer' href='$1'>$1</a>");
         };

         var addNewComment = function(user, avatar, time, comment, first) {
             var commentFiltered = encodeHTML(comment);
             commentFiltered = filterNewlineInComment(filterURLinComment(commentFiltered));
             commentFiltered = commentFiltered.replace(/```/g, '');
             var d = new Date(time * 1000);
             var commentTime = d.toLocaleTimeString() + ' ' + d.toLocaleDateString();
             var anoNameClass = (avatar.indexOf('thefullsnack.com') !== -1) ? "grey" : "";
             var html = '<div class="avatar">' +
                        '   <img src="' + avatar + '?sz=32" width="32" height="32"/>' +
                        ' </div>' +
                        '<div class="comment">' +
                        '  <div class="metadata"><b class="' + anoNameClass + '">' + encodeHTML(user) + '</b> lúc <span>' + commentTime + '</span></div>' +
                        '  <div class="content tex2jax_ignore">' + commentFiltered
             '  </div>' +
                        '</div>';
             var li = document.createElement('li');
             li.innerHTML = html;
             if (!first) {
                 document.getElementById("comment-list").append(li);
             } else {
                 let elm = document.getElementById("comment-list");
                 elm.insertBefore(li, elm.firstChild);
             }
         };



         window.onload = function() {

             document.querySelectorAll("pre code").forEach(el => {
                 hljs.highlightBlock(el);
             });

             start_toc_module();

             firebase.initializeApp(config);
             window.provider = new firebase.auth.GoogleAuthProvider();
             window.auth = firebase.auth();
             window.currentUser = null;

             window.auth.onAuthStateChanged(function(user) {
                 updateAuth(user);
             });


             // Fetch comment and put to posts
             fetch(postCommentURL)
                 .then(res => res.json())
                 .then(data => {
                     if (data.comments) {
                         let comments = data.comments;
                         comments.sort((a, b) => a.post_time - b.post_time);
                         for (let i = 0; i < comments.length; i++) {
                             let cmt = comments[i];
                             addNewComment(cmt.username, cmt.avatar, cmt.post_time, cmt.message);
                         }
                     }
                 });
         };

         var toggle_wordwise = function(status) {
             var book = document.querySelector("book");
             var on = document.querySelector("#ww_on");
             var off = document.querySelector("#ww_off");
             if (!status) {
                 book.className = "off";
                 on.className = "btn-toggle";
                 off.className = "btn-toggle active";
             } else {
                 book.className = "";
                 on.className = "btn-toggle active";
                 off.className = "btn-toggle";
             }
         };
        </script>
</body>

<!-- Mirrored from thefullsnack.com/posts/javascript-promise-va-map.html by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 12 May 2020 03:19:26 GMT -->
</html>
