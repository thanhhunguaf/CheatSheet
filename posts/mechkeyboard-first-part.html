<html>

<!-- Mirrored from thefullsnack.com/posts/mechkeyboard-first-part.html by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 12 May 2020 03:19:44 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf8" /><!-- /Added by HTTrack -->
<head>
<title>Keyboard from Scratch: Prototype | Huy's Blog</title>
<meta charset="utf-8">
<meta http-equiv="content-type" content="text/html;"><meta name=viewport content="initial-scale=1.0 maximum-scale=1.0">
<meta property='og:image' content='img/mech_build.jpg'>
<link rel="apple-touch-icon" sizes="180x180" href="../apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="../favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="../favicon-16x16.png">
<link rel="manifest" href="../manifest.json">
<link rel="mask-icon" href="../safari-pinned-tab.svg" color="#5bbad5">
<meta name="theme-color" content="#ffffff">
<link href="../css/theme.dist.css" rel="stylesheet" type="text/css">
<link rel="stylesheet" href="../emoji/css/emoji.dist.css">
<link href="https://fonts.googleapis.com/css?family=Open+Sans:400,700|Space+Mono:400,700&amp;display=swap&amp;subset=vietnamese" rel="stylesheet">

<script async src="https://www.googletagmanager.com/gtag/js?id=UA-92158965-1"></script>
<script>
	       window.dataLayer = window.dataLayer || [];
	       function gtag(){dataLayer.push(arguments);}
	       gtag('js', new Date());

	       gtag('config', 'UA-92158965-1');
	      </script>
</head>
<body lang="en" class="post">
<div class="header lightweight-theme">
<a href="../index.html"><span class="avatar"></span></a>
</div>
<div class="container">
<div class="main">
<h1><span>Keyboard from Scratch: Prototype</span></h1>
<p>Là một lập trình viên, bàn phím là một vật dụng bạn phải sờ vào hằng ngày, thậm chí số lần bạn sờ nó còn nhiều hơn số lần bạn sờ vào vợ hoặc bạn gái. Chính vì vậy, chúng ta phải đầu tư cho nó một cách xứng đáng, bằng 2 cách:</p>
<ol>
<li>Mua một cái bàn phím cơ</li>
<li>Tự làm một cái</li>
</ol>
<p>Và, với những ai tự gọi mình là kĩ sư (software engineer, backend engineer, frontend engineer, hay copy-pasta engineer, stackoverflow engineer,... nói chung là mọi thể loại engineer), chẳng có lý do gì để không tự làm một cái cho riêng mình, để tự mình quyết định bố cục (layout), màu sắc (keycaps), và tốc dộ gõ (key switches, scanning time).</p>
<p>Suy cho cùng, tự mình build một cái gì đó, và tự tay giải quyết những vấn đề hóc búa trong quá trình build, học hỏi và thu lại được kinh nghiệm cho bản thân, cũng có thể gọi là cái raison d'être của một engineer <i class='em em-smirk'></i>. Hay nói cách khác, như vậy mới gọi là dân chơi đúng nghĩa <i class='em em-joy'></i>.</p>
<p><img src="img/mech_build.jpg" alt="" /></p>
<div class="copyright center">Hình ảnh sẽ xuất hiện trong bài sau, không phải bài này =)))</div>
<p>Đó cũng là lý do mà mình quyết định tự build một cái bàn phím 40% cho riêng mình. Tuy nhiên, làm việc gì cũng có thử nghiệm, thất bại, rút kinh nghiệm,... để hạn chế những vấn đề đó, chúng ta sẽ bắt đầu với một bản prototype đơn giản nhưng đủ phức tạp để thấy được các vấn đề trong thực tế.</p>
<h2><a href="#nguyên-vật-liệu" aria-hidden="true" class="anchor" id="nguyên-vật-liệu"></a>Nguyên vật liệu</h2>
<p>Đối với bản prototype này, chúng ta cần chuẩn bị:</p>
<ul>
<li>4 x Cherry MX Brown Switches (chọn switch nào là sở thích cá nhân thôi, hè hè)</li>
<li>4 x Keycap tùy ý</li>
<li>4 x Diode 1N4148</li>
<li>1 x Teensy 3.2 (hoặc Arduino Pro Micro)</li>
</ul>
<p><del>Hoặc nếu máu thì các bạn có thể <a href="https://www.pjrc.com/store/ic_mkl02.html">tự làm một con Teensy cho riêng mình</a></del> <i class='em em-joy'></i></p>
<h2><a href="#bố-cục-bàn-phím" aria-hidden="true" class="anchor" id="bố-cục-bàn-phím"></a>Bố cục bàn phím</h2>
<p>Đa phần các bàn phím tên tuổi thường chỉ khác nhau về bố cục (layout), và đây là phần bất biến, sau khi sản xuất, còn lại những thứ khác (case, plate, key mapping...) thì đều có thể được custom tùy ý.</p>
<p>Đối với bản prototype này, chúng ta sẽ thiết kế một layout vô cùng phức tạp, như thế này:</p>
<p><img src="img/fourkey.png" alt="" /></p>
<p>Quá phức tạp! <i class='em em-joy'></i> <i class='em em-joy'></i> <i class='em em-joy'></i></p>
<p>Sau khi đã thiết kế xong bố cục thì chúng ta có thể move sang bước tiếp theo đó là thiết kế và cắt tấm đệm (plate).</p>
<p>Trong thiết kế của bàn phím cơ, có 2 cách lắp ghép (mount) swtiches, là <em>Plate Mount</em> và <em>PCB Mount</em>.</p>
<p><img src="img/pcb_vs_plate.jpg" alt="" /></p>
<div class="copyright center">PCB mount bên trái. Plate mount bên phải.<br />Nguồn: https://www.mouser.com/new/Cherry-Electrical/cherry-mx-keyswitch/</div>
<p>PCB Mount là cách lắp các switches trực tiếp trên board mạch. Ưu điểm của thiết kế này là bàn phím nhẹ hơn, cảm giác gõ sâu hơn, có thể cảm nhận rõ độ nẩy và lún của switch. Có khá ít bàn phím thiết kế theo dạng này, có thể kể đến Minvan, KBC Poker,... là các bàn phím như vậy.</p>
<p><img src="img/minivan_pcb_mount.jpg" alt="" /></p>
<div class="copyright center">Nguồn: https://www.extremetech.com/electronics/255783-tiny-keyboard-experiment-living-minivan</div>
<p>Plate Mount là cách lắp các switches trên một tấm nền thường là bằng kim loại, plate thường có độ dày khoảng <code>1.5mm</code> (rất quan trọng nếu bạn tự làm plate), trên thân của switch cũng có các khớp để &quot;móc&quot; vừa vào plate. Sau đó là đến PCB nằm bên dưới.</p>
<p><img src="img/plate_mount.jpg" alt="" /></p>
<div class="copyright center">Nguồn: https://medium.com/@armno/building-my-own-mechanical-keyboard-6903b887b93d</div>
<p>Ưu điểm của cách bố trí này là bàn phím sẽ rất cứng cáp, cảm giác gõ rất chắc chắn, nhưng độ gõ không sâu.</p>
<p>Hầu hết bàn phím cơ trên thị trường được thiết kế dùng plate mount.</p>
<p>Vì bản prototype này chúng ta tự hàn mạch bằng tay chứ chưa thiết kế PCB, nên chúng ta sẽ chọn cách plate mount. Và tùy vào độ khéo tay cũng như vật liệu mà bạn kiếm được, mình suggest dùng giấy bìa cứng =)) cắt một tấm hình vuông nhỏ nhắn xinh xinh kiểu này:</p>
<p><img src="img/fourkey_plate.png" alt="" /></p>
<p>Mấy cái ô trống thì cắt hình vuông là được rồi, không cần phải phức tạp như trong hình kia đâu. Căn cứ vào kích thước của switch (ở đây là Cherry MX), mỗi ô trên plate sẽ có kích thước tầm <code>15mm - 15.6mm</code></p>
<p><img src="img/switch_dimension.jpg" alt="" /></p>
<div class="copyright center">Nguồn: https://www.mouser.com/new/Cherry-Electrical/cherry-mx-keyswitch/</div>
<h2><a href="#mạch-điện" aria-hidden="true" class="anchor" id="mạch-điện"></a>Mạch điện</h2>
<p>Tiếp đến là bước nối mạch điện. Sau khi lắp xong swtich vào plate thì lật ngửa nó ra, các bạn sẽ thấy bố trí như hình bên dưới, với mỗi switch gồm 2 chân, các chân bên trái nằm cao hơn bên phải. Nối diode vào chân bên trái, và nối lại với nhau để tạo thành một hàng, đồng thời, nối các chân bên phải lại với nhau tạo thành các cột.</p>
<p><img src="img/mech_circuit.png" alt="" /></p>
<div class="center">Sơ đồ mạch điện trên lý thuyết</div>
<p><img src="img/mech_circuit_real.jpg" alt="" /></p>
<div class="center">Và thực tế <i class='em em-joy'></i></div>
<p>Cách mắc mạch điện như trên cũng là cách mắc phổ biến trong các loại bàn phím cơ, các switch tạo thành một mam trận nhiều hàng nhiều cột, cách mắc này có ưu điểm là tiết kiệm được số cổng kết nối trên board điều khiển, trong bản prototype này chúng ta không thể thấy rõ điều đó, nhưng giả sử với một bàn phím 60%, thường sẽ có 5 hàng và 15 cột, như vậy ta chỉ cần 20 cổng kết nối trên board điều khiển, nhưng vẫn có thể xử lý được từ 60 đến 65 phím.</p>
<p>Nếu các bạn thắc mắc tại sao phải lắp thêm diode vào các switch thì có thể tham khảo thêm về <a href="https://www.dribin.org/dave/keyboard/one_html/">vấn đề Ghosting</a>.</p>
<p>Sau khi hoàn tất công đoạn hàn mạch, thì chúng ta sẽ nối mạch này vào Teensy, chúng ta gọi các dây xanh là hàng (row), và dây đỏ là cột (column), mạch của chúng ta gồm có 2 hàng và 2 cột, tiến hành nối các hàng và cột này vào 4 cổng digital của Teensy, cổng nào là tùy ý các bạn chọn.</p>
<p><img src="img/mech_teensy.png" alt="" /></p>
<p>Trong hình trên, mình nối các cột vào các chân số 2 và 3. Các hàng vào các chân số 6 và 7.</p>
<h2><a href="#thiết-kế-firmware" aria-hidden="true" class="anchor" id="thiết-kế-firmware"></a>Thiết kế Firmware</h2>
<p>Khi mình bắt đầu phần này thì khá là nhiều người trên Reddit và Geekhack khuyên mình đừng nên tự viết firmware riêng mà hãy dùng các firmware có sẵn như <a href="https://github.com/tmk/tmk_keyboard">TMK</a> hoặc <a href="https://github.com/qmk/qmk_firmware">QMK</a>. Tuy nhiên khi thử build hai loại firmware trên thì rất may là mình dùng Teensy 3.2, board này xài chip ARM 32-bit (Cortex-M4), chưa được support tốt lắm trên cả 2 firmware trên, nên build không chạy được <i class='em em-cry'></i>. Thế nên mình quyết định là tự viết riêng cho mình một bản firmware riêng.</p>
<p>Để cho đơn giản, thì mình sẽ sử dụng <a href="https://www.pjrc.com/teensy/teensyduino.html">Teensyduino</a> để lập trình. Đây là một add-on của Arduino IDE, cho phép chúng ta lập trình trên Teensy bằng bộ thư viện của Arduino, và sử dụng cấu trúc chương trình của Arduino.</p>
<p>Một firmware cơ bản sẽ là một event loop thực hiện các công việc sau:</p>
<ul>
<li><strong>Scan:</strong> quét liên tục để tìm ra các phím được nhấn</li>
<li><strong>Processing:</strong> xây dựng một buffer chứa keycode của các phím đang được nhấn xuống, dựa trên keymap mà chúng ta đã thiết lập.</li>
<li><strong>Output:</strong> Gửi buffer này về máy tính thông qua cổng USB.</li>
</ul>
<p>Trước khi bắt tay vào thực hiện code logic trên, chúng ta cần phải khai báo một vài thông số liên quan:</p>
<pre><code class="language-c">#include &lt;Keyboard.h&gt;

const byte ROWS = 2;
const byte COLS = 2;

char keys[ROWS][COLS] = {
  { 'A', 'B' },
  { 'C', 'D' }
};

const byte rowPins[ROWS] = { 6, 7 };
const byte colPins[COLS] = { 2, 3 };
</code></pre>
<p>Ở trên, chúng ta include thư viện <code>Keyboard.h</code> (đi kèm theo SDK của Arduino), chỉ vì chúng ta muốn sử dụng hàm <code>Keyboard.print()</code> có trong thư viện này để gửi phím được nhấn về cho máy tính.</p>
<p>Tiếp theo, chúng ta khai báo 2 hằng <code>ROWS</code> và <code>COLS</code> quy định số hàng và số cột của bàn phím, mảng <code>keys</code> chính là keymap, là mảng quy ước các kí tự nào thuộc về phím nào trên bàn phím của chúng ta, ở đây khi nhấn các phím <code>1, 2, 3, 4</code> thì bàn phím sẽ gửi về máy tính các kí tự <code>A, B, C, D</code>.</p>
<p>Hai mảng <code>rowPins</code> và <code>colPins</code> lưu vị trí các chân cắm trên board điều khiển, theo như cách chúng ta đã nối dây ở phần trước.</p>
<p>Đến đây, nếu tinh ý thì các bạn sẽ nhận ra, là ở bài viết tiếp theo khi chúng ta xây dựng firmware cho một cái bàn phím thực sự, thì chỉ cần thay đổi các thông số ở trên là xong.</p>
<p>Bây giờ đến phần implement event loop cho firmware của chúng ta, đầy đủ 3 bước <code>scan</code>, <code>process</code> và <code>output</code>:</p>
<pre><code class="language-c">void loop() {
    char code = scan();
    if (code !== -1) {
        char keyCode = process(code);
        output(keyCode);
    }
    delay(50);
}
</code></pre>
<h3><a href="#vấn-đề-1:-quét-tín-hiệu" aria-hidden="true" class="anchor" id="vấn-đề-1:-quét-tín-hiệu"></a>Vấn đề #1: Quét tín hiệu</h3>
<p>Hàm <code>scan()</code> của chúng ta sẽ có nhiệm vụ quét tất cả các hàng và các cột của mạch điện, kiểm tra xem phím nào được nhấn xuống và trả về một giá trị kiểu <code>byte</code> chứa thông tin các phím được nhấn.</p>
<p><em>C không có kiểu byte nên chúng ta dùng kiểu char để thay thế.</em></p>
<p>Để cho đơn giản, thì chúng ta chỉ support việc nhấn một phím một lần, ở bài sau chúng ta sẽ cải tiến firmware để xử lý việc nhấn tổ hợp phím, macro,...</p>
<p>Việc quét phím được thực hiện thông qua thuật toán sau:</p>
<div class="box-green skip" style="padding-left: 10px; padding-right: 10px">
<p>
<b>1:</b> Đưa tất cả các chân về trạng thái INPUT, mang giá trị HIGH</br>
<b>2:</b> Lần lượt đưa từng hàng (row) về trạng thái OUTPUT, giá trị LOW</br>
<b>3:</b> &emsp;Trên mỗi hàng, lần lượt đọc trạng thái của từng cột (col)</br>
<b>4:</b> &emsp;&emsp;Nếu phím K[r][c] tại hàng r cột c được nhấn, cột c sẽ mang giá trị LOW</br>
<b>5:</b> &emsp;&emsp;Ghi nhận giá trị r và c.</br>
<b>6:</b> &emsp;Trả lại trạng thái ban đầu cho hàng hiện tại.</br>
<b>7:</b> Trả về giá trị r và c
</p>
</div>
<p>Nếu cảm thấy khó hiểu ở bước 3 và 4, bạn có thể đọc thêm cách hoạt động của các chân digital <a href="https://www.arduino.cc/reference/en/language/variables/constants/constants/">tại đây</a>.</p>
<p>Vì mạch của chúng ta chỉ đơn giản gồm có 4 nút, mỗi hàng và mỗi cột chỉ có nhiều nhất là 2 phàn tử (index là 0 hoặc 1), vậy nên ta có thể &quot;gói&quot; hai giá trị hàng cột này vào cho một số kiểu <code>byte</code>, bằng phương pháp <a href="matrix-representation.html">dịch bit</a>.</p>
<p>Giả sử chúng ta đang ở hàng <code>r = 0</code> và cột <code>c = 1</code>, chúng ta có thể chèn giá trị <code>r</code> vào bit thứ nhất, và <code>c</code> vào bit thứ 2:</p>
<pre class='math'>$$
\texttt{n = (r << 0) | (c << 1)}
$$</pre>
<p>Khi cần đọc ngược lại thì cũng rất đơn giản:</p>
<pre class='math'>$$
\begin{align}
\texttt{r = (n >> 0) & 1} \\
\texttt{c = (n >> 1) & 1}
\end{align}
$$</pre>
<pre><code class="language-c">char scan() {
    char code = -1;

    // Đưa tất cả các pin về trạng thái INPUT/HIGH
    for (int i = 0; i &lt; ROWS; i++) {
        pinMode(rowPins[i], INPUT_PULLUP);
        digitalWrite(rowPins[i], HIGH);
    }
    for (int i = 0; i &lt; COLS; i++) {
        pinMode(colPins[i], INPUT_PULLUP);
        digitalWrite(colPins[i], HIGH);
    }

    // Đưa từng hàng về trạng thái OUTPUT/LOW và quét
    for (int row = 0; row &lt; ROWS; row++) {
        pinMode(rowPins[row], OUTPUT);
        digitalWrite(rowPins[row], LOW);
        for (int col = 0; col &lt; COLS; col++) {
            if (!digitalRead(colPins[col])) {
                // Lưu giá trị hàng và cột thành một số int
                code = (row &lt;&lt; 0) | (col &lt;&lt; 1);
            }
        }
        pinMode(rowPins[row], INPUT_PULLUP);
        digitalWrite(rowPins[row], HIGH);
    }
    return code;
}
</code></pre>
<h3><a href="#vấn-đề-2:-gửi-tín-hiệu-về-máy-tính" aria-hidden="true" class="anchor" id="vấn-đề-2:-gửi-tín-hiệu-về-máy-tính"></a>Vấn đề #2: Gửi tín hiệu về máy tính</h3>
<p>Tiếp theo, chúng ta cần chuyển thông tin về hàng/cột nhận được thành kí tự đã được khai báo trong keymap.</p>
<p>Bước này khá là đơn giản, chỉ cần đọc giá trị trả về từ hàm <code>scan()</code> và trả về giá trị tương ứng từ mảng <code>keys</code> :</p>
<pre><code class="language-c">char process(char code) {
    return keys[(code &gt;&gt; 0) &amp; 1][(code &gt;&gt; 1) &amp; 1];
}
</code></pre>
<p>Hàm gửi tín hiệu <code>output()</code> sẽ sử dụng hàm <code>Keyboard.print</code> của bộ thư viện <code>Keyboard.h</code> và truyền thông tin sang máy tính:</p>
<pre><code class="language-c">void output(char c) {
    Keyboard.print(c);
}
</code></pre>
<p>Đến bước này, bạn có thể compile và upload firmware vào Teensy để test thử.</p>
<p><img src="img/fourkey_test.gif" alt="" /></p>
<p>Máy tính đã nhận diện được bàn phím mới, và gõ thì có ra được nội dung thật. Tuy nhiên sẽ có một vấn đề đó là hiện tượng nhấn một nút, máy tính sẽ in ra rất nhiều lần phím được nhấn. Đây gọi là hiện tượng key chatter.</p>
<p>Ở bài viết tiếp theo, chúng ta sẽ tìm hiểu sâu hơn về hiện tượng này, và implement kĩ thuật debounce để giải quyết nó.</p>
<div class='other-tags'><b>Tags:</b> <a class='topic-tag' href='../tags/hardware.html'>hardware</a><a class='topic-tag' href='../tags/hacking.html'>hacking</a><a class='topic-tag' href='../tags/keyboard-building.html'>keyboard-building</a></div>
<div class="related-posts" style="margin-top: 15px; border-bottom: 1px solid #eee;">
<p><i class="em em-sun_with_face"></i> Cảm ơn bạn đã theo dõi bài viết! các bạn có thể <a href="https://facebook.com/thefullsnackblog" target="_blank">follow mình trên Facebook</a> để đặt câu hỏi, hoặc nhận thông tin về các bài viết mới.</p>
</div>
<div class="comments">
<ul id="comment-list" class="comment-list"></ul>
<div id="login-box" class="login">
Bạn nghĩ như thế nào về bài viết này?<br /><button onclick="login()">Tham gia bình luận</button>
<div class="copyright">Chức năng này cần liên kết với tài khoản Google<br />Nếu không thích thì có thể comment <button onclick="goninja()">Nặc danh</button></div>
</div>
<div id="comment-box" class="comment-input">
<div class="avatar">
<img id="user-avatar" src="#" width="32" height="32" />
</div>
<div class="input">
<textarea id="comment-content" onkeydown="submitComment(event)" placeholder="Comment gõ vào đây :D"></textarea>
<span>Gõ xong nhấn <kbd>Ctrl</kbd> + <kbd>Enter</kbd> để gửi. Bạn không thể xóa comment sau khi gửi.</span>
<button id="comment-button" onclick="submitData()">Gửi</button>
</div>
</div>
</div>
</div>
</div>
<div class="footer lightweight-theme">
<p>you're free to use the content on this blog for whatever you want</p>
<p>Created with <i class="em em-coffee"></i> <a href="https://github.com/huytd/ristretto-rs">ristretto.rs</a></p>
</div>
<script src="../js/highlight.pack.js"></script>
<script>
        </script>
<script type="text/javascript" async src="../../cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJaxb198.js?config=TeX-MML-AM_CHTML"></script>
<script type="text/x-mathjax-config">
         MathJax.Hub.Config({
             tex2jax: {
                 inlineMath: [['$','$'], ['\\(','\\)']],
                 skipTags: ["script","noscript","style","textarea", "code"],
                 ignoreClass: "tex2jax_ignore|comment|comment-list|content"
             }
         });
        </script>
<script src="../js/toc.js"></script>
<script src="../../www.gstatic.com/firebasejs/3.8.0/firebase.js"></script>
<script>
         let postCommentURL = '../api/post/mechkeyboard-first-part.json';
         // Initialize Firebase
         var config = {
             apiKey: "AIzaSyA1PnIAlJJ-U6iQJMNnCOknBuziBqGMYcY",
             authDomain: "huys-blog-comment.firebaseapp.com",
             databaseURL: "https://huys-blog-comment.firebaseio.com",
             projectId: "huys-blog-comment",
             storageBucket: "huys-blog-comment.appspot.com",
             messagingSenderId: "317330376829"
         };

         var login = function() {
             window.auth.signInWithPopup(provider)
                   .then(function(result) {
                   }).catch(function(err) {
                   });
         };

         var goninja = function() {
             updateAuth({
                 displayName: "Không Tên",
                 photoURL: "https://thefullsnack.com/img/kaonashi.jpg"
             });
         };

         var updateAuth = function(user) {
             if (user) {
                 currentUser = user;
                 // Logged in
                 document.getElementById("login-box").style.display = "none";
                 document.getElementById("comment-box").style.display = "flex";
                 document.getElementById("user-avatar").setAttribute("src", user.photoURL + "?sz=32");
             } else {
                 // Not login yet
                 document.getElementById("comment-box").style.display = "none";
                 document.getElementById("login-box").style.display = "block";
             }
         };

         var encodeHTML = function(s) {
             return s.replace(/</g, '&lt;').replace(/"/g, '&quot;').replace(/>/g, '&gt;');
         };

         var saveNewComment = function(comment) {
             if (!currentUser) {
                 return;
             }
             var commentData = {
                 username: currentUser.displayName,
                 avatar: currentUser.photoURL,
                 post_time: ~~((new Date()).getTime() / 1000),
                 message: encodeHTML(comment)
             };

             fetch(postCommentURL, {
                 method: 'post',
                 headers: {
                     "Content-Type": "application/json"
                 },
                 body: JSON.stringify(commentData)
             }).then((result) => {
                 if (result.status === 200) {
                     addNewComment(commentData.username, commentData.avatar, commentData.post_time, commentData.message);
                 }
             });

             document.getElementById("comment-content").value = "";
         };

         function debounce(func, wait, immediate) {
             var timeout;
             return function() {
                 var context = this, args = arguments;
                 var later = function() {
                     timeout = null;
                     if (!immediate) func.apply(context, args);
                 };
                 var callNow = immediate && !timeout;
                 clearTimeout(timeout);
                 timeout = setTimeout(later, wait);
                 if (callNow) func.apply(context, args);
             };
         };

         var submitData = debounce(function() {
             var comment = document.getElementById("comment-content").value;
             if (comment.length) {
                 saveNewComment(comment);
             }
         }, 250);

         var submitComment = function(e) {
             var keyCode = e.which || e.keyCode;
             var ctrlCode = e.ctrlKey || e.metaKey;
             if (keyCode === 13 && ctrlCode) {
                 submitData();
             }
         };

         var filterNewlineInComment = function(t) {
             return t.replace(/\n/g, "<br/>");
         };

         var filterURLinComment = function(comment) {
             return comment.replace(/(https?:\/\/(?:www\.|(?!www))[a-zA-Z0-9][a-zA-Z0-9-]+[a-zA-Z0-9]\.[^\s]{2,}|www\.[a-zA-Z0-9][a-zA-Z0-9-]+[a-zA-Z0-9]\.[^\s]{2,}|https?:\/\/(?:www\.|(?!www))[a-zA-Z0-9]\.[^\s]{2,}|www\.[a-zA-Z0-9]\.[^\s]{2,})/g, "<a target='_blank' rel='noopener noreferrer' href='$1'>$1</a>");
         };

         var addNewComment = function(user, avatar, time, comment, first) {
             var commentFiltered = encodeHTML(comment);
             commentFiltered = filterNewlineInComment(filterURLinComment(commentFiltered));
             commentFiltered = commentFiltered.replace(/```/g, '');
             var d = new Date(time * 1000);
             var commentTime = d.toLocaleTimeString() + ' ' + d.toLocaleDateString();
             var anoNameClass = (avatar.indexOf('thefullsnack.com') !== -1) ? "grey" : "";
             var html = '<div class="avatar">' +
                        '   <img src="' + avatar + '?sz=32" width="32" height="32"/>' +
                        ' </div>' +
                        '<div class="comment">' +
                        '  <div class="metadata"><b class="' + anoNameClass + '">' + encodeHTML(user) + '</b> lúc <span>' + commentTime + '</span></div>' +
                        '  <div class="content tex2jax_ignore">' + commentFiltered
             '  </div>' +
                        '</div>';
             var li = document.createElement('li');
             li.innerHTML = html;
             if (!first) {
                 document.getElementById("comment-list").append(li);
             } else {
                 let elm = document.getElementById("comment-list");
                 elm.insertBefore(li, elm.firstChild);
             }
         };



         window.onload = function() {

             document.querySelectorAll("pre code").forEach(el => {
                 hljs.highlightBlock(el);
             });

             start_toc_module();

             firebase.initializeApp(config);
             window.provider = new firebase.auth.GoogleAuthProvider();
             window.auth = firebase.auth();
             window.currentUser = null;

             window.auth.onAuthStateChanged(function(user) {
                 updateAuth(user);
             });


             // Fetch comment and put to posts
             fetch(postCommentURL)
                 .then(res => res.json())
                 .then(data => {
                     if (data.comments) {
                         let comments = data.comments;
                         comments.sort((a, b) => a.post_time - b.post_time);
                         for (let i = 0; i < comments.length; i++) {
                             let cmt = comments[i];
                             addNewComment(cmt.username, cmt.avatar, cmt.post_time, cmt.message);
                         }
                     }
                 });
         };

         var toggle_wordwise = function(status) {
             var book = document.querySelector("book");
             var on = document.querySelector("#ww_on");
             var off = document.querySelector("#ww_off");
             if (!status) {
                 book.className = "off";
                 on.className = "btn-toggle";
                 off.className = "btn-toggle active";
             } else {
                 book.className = "";
                 on.className = "btn-toggle active";
                 off.className = "btn-toggle";
             }
         };
        </script>
</body>

<!-- Mirrored from thefullsnack.com/posts/mechkeyboard-first-part.html by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 12 May 2020 03:19:46 GMT -->
</html>
