<html>

<!-- Mirrored from thefullsnack.com/posts/javascript-v8-notes.html by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 12 May 2020 03:19:27 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf8" /><!-- /Added by HTTrack -->
<head>
<title>Vài ghi chép về V8 và Garbage Collection | Huy's Blog</title>
<meta charset="utf-8">
<meta http-equiv="content-type" content="text/html;"><meta name=viewport content="initial-scale=1.0 maximum-scale=1.0">
<meta property='og:image' content='../img/default.jpg'>
<link rel="apple-touch-icon" sizes="180x180" href="../apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="../favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="../favicon-16x16.png">
<link rel="manifest" href="../manifest.json">
<link rel="mask-icon" href="../safari-pinned-tab.svg" color="#5bbad5">
<meta name="theme-color" content="#ffffff">
<link href="../css/theme.dist.css" rel="stylesheet" type="text/css">
<link rel="stylesheet" href="../emoji/css/emoji.dist.css">
<link href="https://fonts.googleapis.com/css?family=Open+Sans:400,700|Space+Mono:400,700&amp;display=swap&amp;subset=vietnamese" rel="stylesheet">

<script async src="https://www.googletagmanager.com/gtag/js?id=UA-92158965-1"></script>
<script>
	       window.dataLayer = window.dataLayer || [];
	       function gtag(){dataLayer.push(arguments);}
	       gtag('js', new Date());

	       gtag('config', 'UA-92158965-1');
	      </script>
</head>
<body lang="en" class="post">
<div class="header lightweight-theme">
<a href="../index.html"><span class="avatar"></span></a>
</div>
<div class="container">
<div class="main">
<h1><span>Vài ghi chép về V8 và Garbage Collection</span></h1>
<p>Bài viết này chỉ đề cập đến V8 (là JavaScript engine đứng sau Google Chrome và NodeJS), sau khi đọc bài này, nên tìm đọc thêm về SpiderMonkey (Firefox), Chakra (Edge) và Carakan (Opera), các yếu tố về kĩ thuật trong các engine này có thể sẽ khác nhiều so với V8.</p>
<p>Lý do chọn viết về V8 thì rất là đơn giản, vì engine này có nguồn tài liệu cực kì phong phú và gần như là, hễ tìm với từ khóa JavaScript engine thì nó cứ ra V8 =))</p>
<p>Thực ra, nếu nhìn nhận một cách khách quan về V8 cũng như những kĩ thuật mà team này bỏ ra cho công việc optimization một ngôn ngữ như JavaScript, và đào sâu vào những kĩ thuật đó, thì đó là một kho tàng kiến thức đồ sộ mà chỉ có dại lắm mới dám bỏ qua không ngó ngàng tới.</p>
<p>Viết bài này, mình không có tham vọng gom hết đống kiến thức đồ sộ đó vào một bài viết nhỏ, nên tất nhiên sẽ còn nhiều điểm thiếu sót, hy vọng các bạn đọc xong sẽ nhiệt tình góp ý, cũng như thu về được một ít thông tin vụn vặt, để từ đó mà đem đào sâu hơn vào engine lý thú này.</p>
<div class="mute">
■ <i class='em em-chicken'></i> Trong khi đọc, các bạn nên hạn chế đọc những dòng in nghiêng, đây là những đoạn bình luận nhố nhăng không đóng góp gì nhiều vào nội dung bài viết =))
</div>
<h2><a href="#hidden-class" aria-hidden="true" class="anchor" id="hidden-class"></a>Hidden Class</h2>
<p>Mọi thứ trong JavaScript đều là <code>object</code>, và mọi thuộc tính của một object thì đều có thể được thêm vào hoặc bỏ đi (thay đổi layout), hoặc thay đổi kiểu dữ liệu (type) bất cứ lúc nào (on the fly). Điều này khiến cho việc optimize một ngôn ngữ &quot;động&quot; như JavaScript (dynamically typed language) trở nên rất khó khăn.</p>
<p>Ví dụ luôn, giả sử ta có đoạn code như thế này:</p>
<pre><code class="language-javascript">class Car {
    door_open() {
        // ...
    }
}

class Girl {
    // girls has no door
}

const open_the_door = (object) =&gt; {
    object.door_open();
};
</code></pre>
<p>Trong ví dụ trên, hàm <code>open_the_door()</code> nhận vào một object và gọi hàm <code>door_open()</code> của object đó, tuy nhiên, vì không có cách nào quy định một cách cụ thể kiểu dữ liệu nhận vào của hàm <code>open_the_door()</code>, compiler sẽ không thể nào biết trước được liệu object truyền vào có tồn tại hàm <code>door_open()</code> hay không. Mà nếu không biết thì phải kiểm tra, bằng cách tra cứu (lookup - duyệt hết toàn bộ hàm/thuộc tính có trong object đó và tìm). Rõ ràng, là không hề tối ưu, và nguyên nhân thì lại do chính thiết kế của JavaScript.</p>
<div class="mute">
■ <i class='em em-chicken'></i> "not a design weakness, but a weakness by design" <i class='em em-shit'></i>
</div>
<p>Team V8 giới thiệu một khái niệm gọi là <code>hidden class</code>, gán vào cho mỗi object để giúp cho việc tracking kiểu và các thuộc tính của chúng một cách thuận tiện hơn. Và mỗi lần object thay đổi, thì <code>hidden class</code> của nó cũng sẽ thay đổi tương ứng.</p>
<p>Một ví dụ thực tế, có lẽ là rất thường gặp:</p>
<pre><code class="language-javascript">let product = {};
product.title = api.getBookTitle(book_id) || &quot;&quot;;
product.pages = api.getBookPages(book_id) || &quot;&quot;;
</code></pre>
<p>Với cách viết như trên, ta có tổng cộng <code>3 lần</code> thay đổi cấu trúc của object <code>product</code>. Đầu tiên, là ở câu lệnh <code>let product = {}</code>, lúc này V8 sẽ tạo ra hidden class <code>C0</code> để biểu diễn cấu trúc của <code>product</code> (là một object rỗng). Tiếp theo, khi gặp câu lệnh gán <code>product.title</code>, thì cấu trúc thay đổi, V8 thay thế hidden class <code>C0</code> thành <code>C1</code> (có thêm thuộc tính <code>.title</code>), và cuối cùng là thành <code>C2</code> ở câu lệnh gán <code>product.pages</code>, quá trình thay đổi diễn ra như hình bên dưới:</p>
<p><img src="img/javascript-v8-hidden-class-001.png" alt="" /></p>
<p>Việc xảy ra đến 3 lần thay đổi cấu trúc, dẫn đến 3 lần V8 phải tạo ra hidden class mới là không hề tối ưu. Ta nên khởi tạo tất cả các thuộc tính của một <code>object</code> ngay trong khi khởi tạo chính <code>object</code> đó, bằng cách viết rút gọn:</p>
<pre><code class="language-javascript">let product = {
    title: api.getBookTitle(book_id) || &quot;&quot;,
    pages: api.getBookPages(book_id) || &quot;&quot;
};
</code></pre>
<p>Với cách viết này, V8 chỉ tạo ra một hidden class duy nhất cho object <code>product</code>, vì không có sự thay đổi cấu trúc nào xảy ra sau câu lệnh khởi tạo:</p>
<p><img src="img/javascript-v8-hidden-class-002.png" alt="" /></p>
<p>Các object có cùng kiểu hoặc cấu trúc (hoặc thuộc cùng một class) thì sẽ có chung một <code>hidden class</code>, V8 sẽ không tạo mới mà sử dụng lại các hidden class đã có nếu trùng khớp.</p>
<p>Ví dụ với câu lệnh sau, hidden class của <code>product</code> thay đổi từ <code>C2</code> về lại <code>C1</code> chứ không tạo mới:</p>
<pre><code class="language-javascript">delete product.pages;
</code></pre>
<p>Tuy nhiên, nếu trong trường hợp trên, thuộc tính bị xóa là <code>.title</code> thì sẽ lại có một hidden class <code>C3</code> được tạo ra.</p>
<p><img src="img/javascript-v8-hidden-class-003.png" alt="" /></p>
<p>Bằng cách sử dụng hidden class, V8 luôn biết trước được cấu trúc của một class/object, từ đó có thể tối ưu việc truy xuất đến các thuộc tính của chúng bằng nhiều cách, một trong các kĩ thuật tối ưu mà V8 áp dụng đó là <code>inline caching</code>.</p>
<p>Có thể hiểu nôm na, inline caching là việc tạo ra &quot;đường tắt&quot; (lưu luôn vị trí chính xác của từng vùng nhớ cho từng thuộc tính vào trong code) giúp cho việc truy xuất đến thuộc tính đó diễn ra nhanh hơn, thay vì cách dùng &quot;đường chính&quot; (thực hiện lookup vị trí của thuộc tính đang cần truy xuất trong bộ nhớ).</p>
<div class="mute">
■ <i class='em em-chicken'></i> Cái chữ "đường tắt" kia đúng ra phải gọi là "fast path", bản thân cái từ đó nó cũng mang nhiều ý nghĩa và đọc vào nghe thấm thía hơn. Thế nào là fast path? có fast hẳn phải có slow, vậy slow path khác fast path như nào? Bạn phải tự đặt ra đc câu hỏi như vậy. Tiếc là viết tiếng Việt không dùng được những cái vô lời hữu ý như vậy được, chán bỏ bà.
</div>
<p>Ví dụ khi truy xuất một thuộc tính của một object:</p>
<pre><code class="language-javascript">let x = product.title;
</code></pre>
<p>Giả sử V8 sẽ sinh ra <del>machine</del> pseudo code để xử lý câu lệnh trên như thế này:</p>
<pre><code class="language-python">create $x
create $product_hidden_class_offset
assign $product_hidden_class_offset = lookup_hidden_class($product)
create $p_title_offset
assign $p_title_offset = lookup_property($product_hidden_class_offset, &quot;title&quot;)
assign $x = $p_title_offset
</code></pre>
<div class="mute">
■ <i class='em em-chicken'></i> Okay, khi thực thi, V8 sẽ sinh ra machine code và chạy trực tiếp đống code đó, trên đây không phải là machine code, mà chỉ là pseudo code mà mình chế ra nhằm giúp dễ theo dõi bài viết hơn mà thôi. Suy cho cùng, đâu có ai muốn đọc machine code trong một bài viết về JavaScript đâu đúng không?
</div>
<p>Ở đây ta thấy có việc tra cứu một thuộc tính xảy ra (hàm <code>lookup_property</code>, giả sử hàm này trả về kết quả là vị trí của vùng nhớ chứa thuộc tính <code>title</code>, là <code>0xDAEDBEEF</code>).</p>
<p>Nếu thuộc tính <code>product.title</code> được sử dụng thường xuyên trong chương trình, thì việc tra cứu liên tục như vậy rất tốn kém, để tối ưu, V8 sẽ cache output của hàm này lại sau lần gọi đầu tiên, để rồi nó sẽ thay đổi đống <del>machine</del> pseudo code đã sinh ra thành:</p>
<pre><code class="language-python">create $x
assign $x = 0xDAEDBEEF
</code></pre>
<p>Trong bài viết tiếp theo, chúng ta sẽ tìm hiểu thêm về cơ chế sinh code và tối ưu động này của V8. Còn bây giờ, hy vọng các bạn đã hiểu được tầm quan trọng của hidden class cũng như những lợi ích mà nó đem lại trong việc cải thiện performance của JavaScript.</p>
<p>Đọc thêm:</p>
<ul>
<li>[1] V8 Design Elements, <a href="https://github.com/v8/v8/wiki/Design-Elements">https://github.com/v8/v8/wiki/Design-Elements</a></li>
<li>[2] Hidden classes in JavaScript and Inline Caching, <a href="https://gist.github.com/twokul/9501770">https://gist.github.com/twokul/9501770</a></li>
</ul>
<h2><a href="#garbage-collection" aria-hidden="true" class="anchor" id="garbage-collection"></a>Garbage Collection</h2>
<p>Nói đến công việc dọn rác (thu dọn và xóa sổ những object/giá trị không còn được dùng tới, trả lại bộ nhớ để dùng cho việc khác), đây là một phần khá quan trọng mà ít người quan tâm trong JavaScript. Ngày nay, khi mà JavaScript được dùng càng nhiều cho cả phía server lẫn các single page application, vòng đời của một JS app ngày một dài ra, vai trò của GC ngày một lớn.</p>
<div class="mute">
■ <i class='em em-chicken'></i> Trước đây nhiều người vẫn hay nói đùa là JavaScript thì cần gì GC, chạy trên browser, khi nào hết mem thằng user nó F5 một phát thì tất cả bay biến hết mẹ nó rồi còn đâu <i class='em em-think-hopeful'></i>
</div>
<p>GC của V8 là một <a href="http://www.memorymanagement.org/glossary/g.html#term-generational-garbage-collection">Generational Garbage Collector</a>. Trong quá trình thực thi, các giá trị (biến, object,...) được tạo ra nằm trong bộ nhớ <code>heap</code>. V8 chia <code>heap</code> ra làm nhiều khu vực, trong đó ta chỉ đề cập đến hai khu vực chính là <code>new-space</code> (chứa các đối tượng nhỏ, có vòng đời ngắn) và <code>old-space</code> (chứa các thành phần sống dai hơn, bự hơn).</p>
<p>Hai khu vực này cũng là hai đối tượng cho hai loại thuật toán GC khác nhau, đó là <code>scavenge</code> và <code>mark-sweep / mark-compact</code>.</p>
<p><img src="img/javascript-v8-gc-001.png" alt="" /></p>
<p>Khi chúng ta khai báo một giá trị mới, giá trị này sẽ được cấp phát nằm rải rác trong khu vực <code>new-space</code>, khu vực này có một kích thước nhất định, thường là rất nhỏ (khoảng 1MB đến 8MB, tùy vào cách hoạt động của ứng dụng). Việc khai báo như thế này tạo ra nhiều khoảng trống không thể sử dụng được trong bộ nhớ.</p>
<div class="mute">
■ <i class='em em-chicken'></i> Vì sao lại có những khoảng trống đó thì là kiến thức cơ bản, và bắt buộc các bạn phải biết, không biết thì Google, mình không thích nói nhiều.
</div>
<p>Khi <code>new-space</code> đã đầy, thì <code>scavenge</code> sẽ được kích hoạt để dọn dẹp các vùng nhớ &quot;chết&quot;, giải phóng mặt bằng, có thể sẽ gom góp các vùng nhớ rời rạc lại gần nhau cho hợp lý, vì <code>new-space</code> rất nhỏ, nên <code>scavenge</code> được kích hoạt rất thường xuyên. Trong quá trình giải tán đô thị của <code>scavenge</code>, nếu các vùng nhớ nào còn trụ lại được sau <code>2</code> chu kỳ, thì được <del>điều đi vùng kinh tế mới</del> promote lên khu vực <code>old-space</code>, nơi mà có sức chứa lên đến hàng trăm megabytes, và là nơi mà thuật toán <code>mark-sweep</code> hoặc <code>mark-compact</code> hoạt động, với chu kỳ dài hơn, ít thường xuyên hơn.</p>
<p>Tất cả những thuật toán GC trên đều hoạt động thông qua hai bước chính là:</p>
<ul>
<li>Bước đánh dấu: thuật toán sẽ duyệt qua tất cả các giá trị có trong khu vực bộ nhớ mà nó quản lý, bước duyệt này đơn giản chỉ là <code>depth-first search</code>, tìm gặp và đánh dấu.</li>
<li>Bước xử lý: sau quá trình duyệt, tất cả những giá trị chưa được đánh dấu, sẽ bị coi là đã &quot;chết&quot;, và sẽ bị xóa bỏ, trả lại bộ nhớ trống (<code>sweep</code>), hoặc gom góp lại để lấy lại các khoảng trống trong bộ nhớ không sử dụng được (<code>compact</code>).</li>
</ul>
<p>Điểm khác nhau giữa <code>scavenge</code> và <code>mark-sweep/mark-compact</code> nằm ở cách mà chúng được implement, các bạn có thể xem thêm chi tiết về hai thuật toán trên trong bài <strong>A tour of V8: Garbage Collection</strong> mà mình sẽ dẫn link bên dưới.</p>
<hr />
<p>Về nguyên lý đánh dấu (<code>marking</code>) của các thuật toán trên, chúng ta sẽ làm quen với khái niệm <code>reachability</code>.</p>
<p>Tất cả mọi đối tượng được khai báo trong global scope, hoặc các DOM elements thì được gọi là <code>root</code>. Và đứng từ các <code>roots</code>, tất cả mọi giá trị local có quan hệ trực tiếp hoặc gián tiếp với các <code>roots</code> này sẽ được coi là còn &quot;sống&quot; (<code>reachable</code>). Những đối tượng nào không có mối liên hệ trực tiếp hoặc gián tiếp vói bất kì <code>roots</code> nào, thì coi như là đã &quot;chết&quot; (<code>unreachable</code>).</p>
<p>Ví dụ với đoạn code sau:</p>
<pre><code class="language-javascript">let a = { name: &quot;huy&quot; };

function hello() {
    let b = a;
    // you're here
}
</code></pre>
<p>Trạng thái của heap và sơ đồ biểu diễn reachability của từng giá trị, ngay tại vị trí <code>// you're here</code> được thể hiện như sau:</p>
<p><img src="img/javascript-v8-gc-002.png" alt="" /></p>
<p>Ở đây ta có <code>a</code> và <code>hello</code> là hai giá trị thuộc global scope, vì thế chúng được gọi là các <code>root</code>. Biến <code>a</code> tham chiếu đến một object nằm trong heap, và biến <code>b</code> bên trong hàm <code>hello</code> cũng tham chiếu tới chính object này.</p>
<p>Khi hàm <code>hello()</code> được thực thi xong, và chúng ta đi ra khỏi scope của hàm đó, thì mọi tham chiếu đến các giá trị bên trong hàm đó đều sẽ bị hủy đi, lúc này <code>b</code> trở thành <code>unreachable</code>, và sẽ trở thành đối tượng để bị GC nó thịt (mặc dù bị thịt lúc nào thì không ai biết trước được).</p>
<p><img src="img/javascript-v8-gc-003.png" alt="" /></p>
<p>Lưu ý, đối với các <code>root</code>, chúng ta không thể sử dụng lệnh <code>delete</code> để xóa sổ chúng, ví dụ:</p>
<pre><code class="language-javascript">delete a; // trả về false
delete hello; // trả về false
</code></pre>
<p>Nhưng chúng ta có thể gán chúng bằng <code>null</code> để cho các giá trị mà chúng tham chiếu tới bị GC hốt (nhưng chính biến đó thì lại vẫn còn tồn tại, ở đây, cả <code>a</code> lẫn <code>hello</code> đều vẫn bảo toàn tính mạng), ví dụ, sau lệnh dưới đây, sơ đồ của chúng ta sẽ là:</p>
<pre><code class="language-javascript">a = null;
</code></pre>
<p><img src="img/javascript-v8-gc-004.png" alt="" /></p>
<p>Vậy thì đến bao giờ <code>a</code> và <code>hello</code> mới bị giải phóng khỏi bộ nhớ? Câu trả lời là: chừng nào ứng dụng của chúng ta còn chạy, thì chúng vẫn sẽ còn tồn tại trong bộ nhớ. Dân gian gọi là memory leak. Chính vì thế, nên hạn chế việc tạo và sử dụng các biến global, nếu không thực sự cần thiết.</p>
<hr />
<p>Nói tiếp về vấn đề khi sử dụng <code>delete</code> và <code>null</code>, ở trên chúng ta đã biết <code>delete</code> không thể xóa sổ các <code>root</code>, tuy nhiên nó vẫn hoạt động tốt thuộc tính của các object:</p>
<pre><code>delete a.name;
</code></pre>
<p>Khi chạy lệnh trên, ta có thể chủ động làm cho giá trị <code>a.name</code> trở thành mục tiêu của GC, nhưng cách này có một hiệu ứng tiêu cực, đó là nó làm thay đổi <code>hidden class</code> của <code>a</code>, mà như chúng ta đã biết ở phần trước, việc này gây ảnh hưởng tới performance. Tương tự, nếu chúng ta gán <code>a.name</code> là <code>null</code>, nó cũng sẽ trở thành mục tiêu của GC.</p>
<pre><code>a.name = null;
</code></pre>
<p>Nhưng lại một lần nữa, việc gán một biến thành <code>null</code> chỉ có thể làm cho <code>giá trị mà biến đó tham chiếu tới</code> trở thành mục tiêu bị xóa sổ, nhưng không thể xóa sổ chính biến đó. Trong trường hợp này thì biến <code>a.null</code> vẫn còn tồn tại.</p>
<p>Cách tốt nhất để hủy một giá trị là đưa nó vào một scope nào đó, ví dụ như sử dụng JS Modules hoặc IIFE (immediately invoked function expression):</p>
<pre><code class="language-javascript">(function() {
    let a = { name: &quot;huy&quot; };
})();

a; // ReferenceError: a is not defined
</code></pre>
<hr />
<p>Tiếp, khi truyền một hàm vào <code>setInterval</code> hoặc <code>setTimeout</code>, một tham chiếu đến hàm đó sẽ được tạo ra, khiến cho hàm này không thể bị GC hốt, dù cho chúng ta đã ra khỏi scope chứa nó, và sẽ vẫn tồn tại cho đến chừng nào nó được kích hoạt.</p>
<p>Đối với trường hợp của <code>setTimeout</code>, chúng ta có thể yên tâm, vì sau một khoảng thời gian, nó sẽ được chạy, và cuối cùng sẽ bị GC hốt, tuy nhiên đối với <code>setInterval</code>, chuyện lại không hề đơn giản:</p>
<pre><code class="language-javascript">function do_something() {
    setInterval(function run() {
        // do something
    }, 1000);
}
// you're here
</code></pre>
<p><img src="img/javascript-v8-gc-005.png" alt="" /></p>
<p>Hàm <code>run</code> vẫn còn tồn tại và vẫn còn được thực thi sau mỗi 1 giây, kể cả khi hàm <code>do_something</code> đã kết thúc vòng đời của nó. Chính vì thế, phải luôn luôn lưu lại tham chiếu của mỗi câu lệnh <code>setInterval</code>, và chạy <code>clearInterval</code> khi không còn cần đến:</p>
<pre><code class="language-javascript">function do_something() {
    let runner = setInterval(function run() {
        // do something
    }, 1000);
    
    // do more thing

    clearInterval(runner);
}
</code></pre>
<hr />
<p>Một vài lưu ý khác, GC của V8 là <code>stop-the-world</code>, có nghĩa là, khi GC chạy thì toàn bộ chương trình sẽ bị dừng lại, thời gian dừng có khi lên đến vài trăm mili giây, là một con số khá lớn.</p>
<p>Team V8 áp dụng một vài kĩ thuật khác gọi là <code>concurrent marking</code>, giúp cho ứng dụng JavaScript vẫn có thể được thực thi (tất nhiên là concurrent) trong khi GC hoạt động. Tuy không hoàn toàn giúp cho ứng dụng tránh bị đứng, nhưng cũng cải thiện được performance rõ rệt, các bạn có thể đọc thêm qua bài <strong>Concurrent marking in V8</strong> (link bên dưới).</p>
<hr />
<p>Trên đây là một vài ghi chép về Garbage Collection trong V8, hy vọng qua bài viết này, các bạn đã hiểu thêm phần nào về những gì xảy ra bên dưới một ứng dụng JavaScript, và về cách mà JavaScript hoạt động, từ đó có cái nhìn sâu sắc hơn, và cẩn trọng hơn trong quá trình làm việc với thứ ngôn ngữ quái đản đó.</p>
<p>Hôm nào có thời gian mình sẽ làm một bài đi sâu hơn về cơ chế thực thi code của V8 (Crankshaft, TurboFan,...). Cảm ơn các bạn đã đọc đến tận những dòng này <i class='em em-think-hopeful'></i></p>
<p>Đọc thêm:</p>
<ul>
<li>[1]: Garbage Collection, <a href="http://javascript.info/garbage-collection">http://javascript.info/garbage-collection</a></li>
<li>[2]: A tour of V8: Garbage Collection, <a href="http://jayconrod.com/posts/55/a-tour-of-v8-garbage-collection">http://jayconrod.com/posts/55/a-tour-of-v8-garbage-collection</a></li>
<li>[3]: Concurrent marking in V8, <a href="https://v8project.blogspot.com/2018/06/concurrent-marking.html">https://v8project.blogspot.com/2018/06/concurrent-marking.html</a></li>
<li>[4]: How To Write Fast, Memory-Efficient JavaScript, <a href="https://www.smashingmagazine.com/2012/11/writing-fast-memory-efficient-javascript/">https://www.smashingmagazine.com/2012/11/writing-fast-memory-efficient-javascript/</a></li>
</ul>
<div class='other-tags'><b>Tags:</b> <a class='topic-tag' href='../tags/javascript.html'>javascript</a><a class='topic-tag' href='../tags/v8.html'>v8</a></div>
<div class="related-posts" style="margin-top: 15px; border-bottom: 1px solid #eee;">
<p><i class="em em-sun_with_face"></i> Cảm ơn bạn đã theo dõi bài viết! các bạn có thể <a href="https://facebook.com/thefullsnackblog" target="_blank">follow mình trên Facebook</a> để đặt câu hỏi, hoặc nhận thông tin về các bài viết mới.</p>
</div>
<div class="comments">
<ul id="comment-list" class="comment-list"></ul>
<div id="login-box" class="login">
Bạn nghĩ như thế nào về bài viết này?<br /><button onclick="login()">Tham gia bình luận</button>
<div class="copyright">Chức năng này cần liên kết với tài khoản Google<br />Nếu không thích thì có thể comment <button onclick="goninja()">Nặc danh</button></div>
</div>
<div id="comment-box" class="comment-input">
<div class="avatar">
<img id="user-avatar" src="#" width="32" height="32" />
</div>
<div class="input">
<textarea id="comment-content" onkeydown="submitComment(event)" placeholder="Comment gõ vào đây :D"></textarea>
<span>Gõ xong nhấn <kbd>Ctrl</kbd> + <kbd>Enter</kbd> để gửi. Bạn không thể xóa comment sau khi gửi.</span>
<button id="comment-button" onclick="submitData()">Gửi</button>
</div>
</div>
</div>
</div>
</div>
<div class="footer lightweight-theme">
<p>you're free to use the content on this blog for whatever you want</p>
<p>Created with <i class="em em-coffee"></i> <a href="https://github.com/huytd/ristretto-rs">ristretto.rs</a></p>
</div>
<script src="../js/highlight.pack.js"></script>
<script>
        </script>
<script type="text/javascript" async src="../../cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJaxb198.js?config=TeX-MML-AM_CHTML"></script>
<script type="text/x-mathjax-config">
         MathJax.Hub.Config({
             tex2jax: {
                 inlineMath: [['$','$'], ['\\(','\\)']],
                 skipTags: ["script","noscript","style","textarea", "code"],
                 ignoreClass: "tex2jax_ignore|comment|comment-list|content"
             }
         });
        </script>
<script src="../js/toc.js"></script>
<script src="../../www.gstatic.com/firebasejs/3.8.0/firebase.js"></script>
<script>
         let postCommentURL = '../api/post/javascript-v8-notes.json';
         // Initialize Firebase
         var config = {
             apiKey: "AIzaSyA1PnIAlJJ-U6iQJMNnCOknBuziBqGMYcY",
             authDomain: "huys-blog-comment.firebaseapp.com",
             databaseURL: "https://huys-blog-comment.firebaseio.com",
             projectId: "huys-blog-comment",
             storageBucket: "huys-blog-comment.appspot.com",
             messagingSenderId: "317330376829"
         };

         var login = function() {
             window.auth.signInWithPopup(provider)
                   .then(function(result) {
                   }).catch(function(err) {
                   });
         };

         var goninja = function() {
             updateAuth({
                 displayName: "Không Tên",
                 photoURL: "https://thefullsnack.com/img/kaonashi.jpg"
             });
         };

         var updateAuth = function(user) {
             if (user) {
                 currentUser = user;
                 // Logged in
                 document.getElementById("login-box").style.display = "none";
                 document.getElementById("comment-box").style.display = "flex";
                 document.getElementById("user-avatar").setAttribute("src", user.photoURL + "?sz=32");
             } else {
                 // Not login yet
                 document.getElementById("comment-box").style.display = "none";
                 document.getElementById("login-box").style.display = "block";
             }
         };

         var encodeHTML = function(s) {
             return s.replace(/</g, '&lt;').replace(/"/g, '&quot;').replace(/>/g, '&gt;');
         };

         var saveNewComment = function(comment) {
             if (!currentUser) {
                 return;
             }
             var commentData = {
                 username: currentUser.displayName,
                 avatar: currentUser.photoURL,
                 post_time: ~~((new Date()).getTime() / 1000),
                 message: encodeHTML(comment)
             };

             fetch(postCommentURL, {
                 method: 'post',
                 headers: {
                     "Content-Type": "application/json"
                 },
                 body: JSON.stringify(commentData)
             }).then((result) => {
                 if (result.status === 200) {
                     addNewComment(commentData.username, commentData.avatar, commentData.post_time, commentData.message);
                 }
             });

             document.getElementById("comment-content").value = "";
         };

         function debounce(func, wait, immediate) {
             var timeout;
             return function() {
                 var context = this, args = arguments;
                 var later = function() {
                     timeout = null;
                     if (!immediate) func.apply(context, args);
                 };
                 var callNow = immediate && !timeout;
                 clearTimeout(timeout);
                 timeout = setTimeout(later, wait);
                 if (callNow) func.apply(context, args);
             };
         };

         var submitData = debounce(function() {
             var comment = document.getElementById("comment-content").value;
             if (comment.length) {
                 saveNewComment(comment);
             }
         }, 250);

         var submitComment = function(e) {
             var keyCode = e.which || e.keyCode;
             var ctrlCode = e.ctrlKey || e.metaKey;
             if (keyCode === 13 && ctrlCode) {
                 submitData();
             }
         };

         var filterNewlineInComment = function(t) {
             return t.replace(/\n/g, "<br/>");
         };

         var filterURLinComment = function(comment) {
             return comment.replace(/(https?:\/\/(?:www\.|(?!www))[a-zA-Z0-9][a-zA-Z0-9-]+[a-zA-Z0-9]\.[^\s]{2,}|www\.[a-zA-Z0-9][a-zA-Z0-9-]+[a-zA-Z0-9]\.[^\s]{2,}|https?:\/\/(?:www\.|(?!www))[a-zA-Z0-9]\.[^\s]{2,}|www\.[a-zA-Z0-9]\.[^\s]{2,})/g, "<a target='_blank' rel='noopener noreferrer' href='$1'>$1</a>");
         };

         var addNewComment = function(user, avatar, time, comment, first) {
             var commentFiltered = encodeHTML(comment);
             commentFiltered = filterNewlineInComment(filterURLinComment(commentFiltered));
             commentFiltered = commentFiltered.replace(/```/g, '');
             var d = new Date(time * 1000);
             var commentTime = d.toLocaleTimeString() + ' ' + d.toLocaleDateString();
             var anoNameClass = (avatar.indexOf('thefullsnack.com') !== -1) ? "grey" : "";
             var html = '<div class="avatar">' +
                        '   <img src="' + avatar + '?sz=32" width="32" height="32"/>' +
                        ' </div>' +
                        '<div class="comment">' +
                        '  <div class="metadata"><b class="' + anoNameClass + '">' + encodeHTML(user) + '</b> lúc <span>' + commentTime + '</span></div>' +
                        '  <div class="content tex2jax_ignore">' + commentFiltered
             '  </div>' +
                        '</div>';
             var li = document.createElement('li');
             li.innerHTML = html;
             if (!first) {
                 document.getElementById("comment-list").append(li);
             } else {
                 let elm = document.getElementById("comment-list");
                 elm.insertBefore(li, elm.firstChild);
             }
         };



         window.onload = function() {

             document.querySelectorAll("pre code").forEach(el => {
                 hljs.highlightBlock(el);
             });

             start_toc_module();

             firebase.initializeApp(config);
             window.provider = new firebase.auth.GoogleAuthProvider();
             window.auth = firebase.auth();
             window.currentUser = null;

             window.auth.onAuthStateChanged(function(user) {
                 updateAuth(user);
             });


             // Fetch comment and put to posts
             fetch(postCommentURL)
                 .then(res => res.json())
                 .then(data => {
                     if (data.comments) {
                         let comments = data.comments;
                         comments.sort((a, b) => a.post_time - b.post_time);
                         for (let i = 0; i < comments.length; i++) {
                             let cmt = comments[i];
                             addNewComment(cmt.username, cmt.avatar, cmt.post_time, cmt.message);
                         }
                     }
                 });
         };

         var toggle_wordwise = function(status) {
             var book = document.querySelector("book");
             var on = document.querySelector("#ww_on");
             var off = document.querySelector("#ww_off");
             if (!status) {
                 book.className = "off";
                 on.className = "btn-toggle";
                 off.className = "btn-toggle active";
             } else {
                 book.className = "";
                 on.className = "btn-toggle active";
                 off.className = "btn-toggle";
             }
         };
        </script>
</body>

<!-- Mirrored from thefullsnack.com/posts/javascript-v8-notes.html by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 12 May 2020 03:19:30 GMT -->
</html>
