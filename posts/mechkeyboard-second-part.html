<html>

<!-- Mirrored from thefullsnack.com/posts/mechkeyboard-second-part.html by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 12 May 2020 03:19:14 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf8" /><!-- /Added by HTTrack -->
<head>
<title>Keyboard from Scratch: Debounce | Huy's Blog</title>
<meta charset="utf-8">
<meta http-equiv="content-type" content="text/html;"><meta name=viewport content="initial-scale=1.0 maximum-scale=1.0">
<meta property='og:image' content='img/mech_build.jpg'>
<link rel="apple-touch-icon" sizes="180x180" href="../apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="../favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="../favicon-16x16.png">
<link rel="manifest" href="../manifest.json">
<link rel="mask-icon" href="../safari-pinned-tab.svg" color="#5bbad5">
<meta name="theme-color" content="#ffffff">
<link href="../css/theme.dist.css" rel="stylesheet" type="text/css">
<link rel="stylesheet" href="../emoji/css/emoji.dist.css">
<link href="https://fonts.googleapis.com/css?family=Open+Sans:400,700|Space+Mono:400,700&amp;display=swap&amp;subset=vietnamese" rel="stylesheet">

<script async src="https://www.googletagmanager.com/gtag/js?id=UA-92158965-1"></script>
<script>
	       window.dataLayer = window.dataLayer || [];
	       function gtag(){dataLayer.push(arguments);}
	       gtag('js', new Date());

	       gtag('config', 'UA-92158965-1');
	      </script>
</head>
<body lang="en" class="post">
<div class="header lightweight-theme">
<a href="../index.html"><span class="avatar"></span></a>
</div>
<div class="container">
<div class="main">
<h1><span>Keyboard from Scratch: Debounce</span></h1>
<p><em>Bạn đang xem phần hai của một <a href="../tags/keyboard-building.html">sê ri nhiều phần</a>, nhiều chừng nào, nhiều đến khi nào, thì chưa biết được.</em></p>
<p>Ở phần trước, chúng ta đã <em>sắp</em> hoàn thiện một bản prototype bàn phím nho nhỏ với 4 nút, đáng ra ở bài này chúng ta đã có thể đi từ prototype đến thực tế, bắt tay vào thiết kế một quả phím cơ hoàn chỉnh, nhưng không, chúng ta gặp lỗi nhảy phím.</p>
<video style="max-width: 500px; margin: 0 auto;" autoplay loop>
<source type="video/mp4" src="img/mech-keyboard-part2/fourkey_test.mp4">
<img src="img/mech-keyboard-part2/fourkey_test.gif" />
</video>
<div class="center mute">Video chỉ mang tính chất minh họa, căng mắt ra thì may ra còn thấy...</div>
<p>Khi gõ, thì đôi lúc thay vì một kí tự được gửi đến máy tính, sẽ có 2, 3 kí tự cùng lúc.<span class="mute sidenote"><i class="em em-pig"></i> Lỗi này rất tai ương, trong mọi trường hợp, hãy tưởng tượng bạn đang ngồi xem phim heu thì phụ huynh bước vào, bạn nhanh tay nhấn Alt+Tab một cái, nhưng khốn nạn thay, máy tính lại nhận được hai cái...</span> Ví dụ gõ <code>ABCAB</code> thì trên máy tính lại nhận được <code>AAABCCABBB</code>, kiểu vậy. Lỗi này gọi là <strong>bounce</strong>, hay <strong>key chatter</strong>. Và kĩ thuật để fix lỗi này, đương nhiên được gọi là <strong>debounce</strong>.</p>
<h2><a href="#tại-sao-lại-xảy-ra-hiện-tượng-bouncekey-chatter?" aria-hidden="true" class="anchor" id="tại-sao-lại-xảy-ra-hiện-tượng-bouncekey-chatter?"></a>Tại sao lại xảy ra hiện tượng bounce/key chatter?</h2>
<p>Các linh kiện như nút bấm, switch được cấu tạo từ nhiều thành phần, trong đó phần cơ thường sẽ bằng kim loại có tính đàn hồi.</p>
<p>Khi chúng ta nhấn xuống hoặc thả ra, các phần cơ bằng kim loại này xảy ra sự tiếp xúc với nhau tạo ra một mạch kín để truyền tín hiệu đi, nhưng vì tính đàn hồi, các phần kim loại này cứ liên tục va chạm rồi tách ra (bounce), có khi từ 10 đến 100 lần trong khoảng 1 milli-giây <sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>. Gây ra nhiễu khi ta đọc tín hiệu từ switch/nút.</p>
<p><img src="img/switch-bounce.png" alt="" /></p>
<div class="center mute">Nhiễu tín hiệu của switch Cherry MX Brown. Nguồn: https://geekhack.org/index.php?topic=42385.0</div>
<p>Như hình trên, khi switch chuyển từ tín hiệu mở (bên trái) sang đóng (bên phải), hiện tượng bounce xảy ra ở giai đoạn chuyển tiếp, gây ra nhiễu. Tùy vào mỗi loại nút/switch khác nhau (dựa trên cấu tạo, chất liệu, kĩ thuật sản xuất,...) mà cái sơ đồ tín hiệu sẽ thể hiện cái sự nhiễu khác nhau.</p>
<p>Và mặc dù bạn thấy tín hiệu nhiễu nó lên lên xuống xuống không ra ất giáp gì, nhưng vì khi viết firmware, chúng ta đọc các tín hiệu này dưới dạng digital (bằng hàm <code>digitalRead()</code>), nên chúng ta sẽ thu về được một chuỗi tín hiệu LOW/HIGH kiểu như hình sau:</p>
<p><img src="img/mech-keyboard-part2/bounce.png" alt="" /></p>
<p>Mỗi lần tín hiệu HIGH xuất hiện là một lần chúng ta gửi key event đến máy tính, và như thế là bạn đã có thể hình dung ra, hiện tượng key chatter xảy ra như thế nào rồi đó.</p>
<p>Việc chúng ta cần làm là, đọc theo một cách nào đó để loại bỏ phần tín hiệu noise này đi, đưa tín hiệu về dạng ổn định hơn, việc này gọi là <strong>debounce</strong>.</p>
<h2><a href="#giải-pháp-debounce" aria-hidden="true" class="anchor" id="giải-pháp-debounce"></a>Giải pháp debounce</h2>
<p>Có rất nhiều cách để debounce, cả bằng phần cứng lẫn phần mềm, mình cũng không có ý định viết sâu về các cách này, cho nên các bạn có thể đọc thêm trong các link tham khảo ở cuối bài <sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup> <sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup> <sup class="footnote-ref"><a href="#fn4" id="fnref4">[4]</a></sup> <sup class="footnote-ref"><a href="#fn5" id="fnref5">[5]</a></sup>.</p>
<p>Ở đây mình sẽ chọn cách debounce bằng phần mềm<span class="mute sidenote">Cũng cần phải nói thêm, debouncing bằng phần mềm không phải là một giải pháp tối ưu, hiển nhiên rồi, làm sao chúng ta có thể giải quyết triệt để một vấn đề mang tính vật lý chỉ bằng một thứ giải pháp phi vật chất chứ <i class='em em-joy'></i> ngoài yếu tố vật lý đến từ tính đàn hồi của những thứ bên trong switch, người ta thậm chí còn tính tới những thứ như <em>nhiễu sóng điện từ</em> (electromagnetic interference, EMI) <i class='em em-scream'></i>. <sup class="footnote-ref"><a href="#fn6" id="fnref6">[6]</a></sup></span>, và sử dụng phương pháp đơn giản nhất, đó là <strong>phương pháp đếm và chờ</strong>.</p>
<p>Ta có thể mô tả thuật toán này như sau:</p>
<div class="box-green skip" style="padding-left: 10px; padding-right: 10px">
<p>
<b>1:</b> Lặp vô hạn:<br>
<b>2:</b> &nbsp;Tăng biến đếm lên một đơn vị.<br>
<b>3:</b> &nbsp;Nếu đã đến thời gian cho phép nhận phím (REGISTER_DELAY):<br>
<b>4:</b> &nbsp;&nbsp;Quét và gửi phím được nhấn nếu có.<br>
<b>5:</b> &nbsp;Nếu đã đủ thời gian cho một chu kỳ xử lý (REPEAT_DELAY):<br>
<b>6:</b> &nbsp;&nbsp;Reset lại biến đếm và chờ vòng lặp tiếp theo.<br>
</p>
</div>
<p>Vì Teensy 3.2 (microcontroller được dùng trong bài) có xung nhịp là 96MHz, như vậy hàm <code>loop()</code> sẽ được chạy với chu kì 96 triệu lần / giây, mỗi vòng lặp sẽ có thời lượng xấp xỉ 10.4 nano-giây. Tương tự, nếu bạn sử dụng microcontroller khác, có xung nhịp khác, thì thời lượng của mỗi frame cũng khác đi. Để cho ổn định, ta sẽ giới hạn chu kì xử lý lại về mỗi 1 milli-giây.</p>
<p>Thuật toán này có hai giá trị thời gian cần lưu ý đó là <code>REGISTER_DELAY</code>, chỉ khoảng thời gian mà ta có phải chờ để có thể quét phím khi bắt đầu một vòng lặp mới, mục đích của giá trị này nhằm hạn chế việc quét và gửi phím liên tục để tránh ghi nhận các tín hiệu khi bị bouncing. Giá trị tiếp theo là <code>REPEAT_DELAY</code>, chỉ khoảng thời gian từ lúc bắt đầu cho tới lúc chúng ta cho phép vòng lặp tiếp theo diễn ra, khi bạn nhấn giữ phím thì đây sẽ là khoảng thời gian chờ giữa hai lần mã phím được gửi đi.</p>
<p>Với mạch prototype của mình, hai giá trị này lần lượt là <code>REGISTER_DELAY = 10</code>, <code>REPEAT_DELAY = 80</code>.</p>
<p>Implementation sẽ như thế này:</p>
<pre><code>const byte REGISTER_DELAY = 10;
const byte REPEAT_DELAY = 80;
int frameCount = 0;
unsigned long lastFrame = 0;

void loop() {
    unsigned long timeNow = millis();
    if (timeNow != lastFrame) {
        frameCount++;
        if (frameCount == REGISTER_DELAY) {
        // Begin process
        int code = scan();
        if (code != -1) {
            char keyCode = process(code);
            output(keyCode);
        } else {
            frameCount = 0;
        }
    }
    if (frameCount == REPEAT_DELAY) {
        frameCount = 0;
    }
    lastFrame = timeNow;
}
</code></pre>
<p>Và đây là thành quả:</p>
<video style="max-width: 500px; margin: 0 auto;" autoplay loop>
<source type="video/mp4" src="img/mech-keyboard-part2/final.mp4">
<img src="img/mech-keyboard-part2/final.gif" />
</video>
<p>Phèo, vậy là cuối cùng cũng đã giải quyết xong một trong những phần rắc rối nhất. Các bạn có thể tham khảo <a href="https://gist.github.com/huytd/8dabf762a868b86d2aa597b878e53df0">mã nguồn đầy đủ của bản prototype</a> trên Gist của mình. Thực ra từ đầu mình cũng không có ý định viết kĩ về phần này, chỉ viết vội cho xong để mà còn bắt tay vô phần sau thú vị hơn <i class='em em-grin'></i> cho nên nếu có gì khó hiểu hoặc thiếu sót, mong các bạn lượng thứ và nhiệt tình góp ý.</p>
<p>Rất cảm ơn các bạn đã theo dõi bài viết. Hẹn gặp lại các bạn ở phần tiếp theo <del>vào một ngày nào đó</del>, trong phần tới, chúng ta sẽ bắt tay vào thiết kế layout và mạch in cho một phiên bản bàn phím 40% hoàn chỉnh.</p>
<hr />
<center><b>Ghi chú</b></center>
<section class="footnotes">
<ol>
<li id="fn1">
<p>Thông tin này được ghi trong quyển <strong>The Art of Electronics 2nd Edition</strong>, mình chưa đọc, nhưng được trích dẫn rất nhiều. Xem: <a href="http://www.eng.uwaterloo.ca/~tnaqvi/downloads/DOC/sd192/SwitchDebouncing.htm">http://www.eng.uwaterloo.ca/~tnaqvi/downloads/DOC/sd192/SwitchDebouncing.htm</a> <a href="#fnref1" class="footnote-backref">↩</a></p>
</li>
<li id="fn2">
<p>My favorite software debouncers, Jack Ganssle, <a href="https://www.embedded.com/electronics-blogs/break-points/4024981/My-favorite-software-debouncers">https://www.embedded.com/electronics-blogs/break-points/4024981/My-favorite-software-debouncers</a> <a href="#fnref2" class="footnote-backref">↩</a></p>
</li>
<li id="fn3">
<p>A Guide to Debouncing, Jack Ganssle, <a href="http://www.ganssle.com/debouncing-pt2.htm">http://www.ganssle.com/debouncing-pt2.htm</a> <a href="#fnref3" class="footnote-backref">↩</a></p>
</li>
<li id="fn4">
<p>Debounce your Noisy Buttons, Elliot Williams, <a href="https://hackaday.com/2015/12/09/embed-with-elliot-debounce-your-noisy-buttons-part-i/">https://hackaday.com/2015/12/09/embed-with-elliot-debounce-your-noisy-buttons-part-i/</a> <a href="#fnref4" class="footnote-backref">↩</a></p>
</li>
<li id="fn5">
<p>Keyboard Matrix Scanning and Debouncing, Yin Zhong, <a href="https://summivox.wordpress.com/2016/06/03/keyboard-matrix-scanning-and-debouncing/">https://summivox.wordpress.com/2016/06/03/keyboard-matrix-scanning-and-debouncing/</a> <a href="#fnref5" class="footnote-backref">↩</a></p>
</li>
<li id="fn6">
<p>Nói để thấy, bouncing là một vấn đề cực kì phức tạp vì phụ thuộc vào nhiều yếu tố, và debouncing giống như là trò rút dây, kéo bên này thì buộc phải hụt bên kia (trade off). Rất may, vấn đề chúng ta đang giải quyết chỉ gói gọn trong phạm vi một cái bàn phím dùng switch Cherry MX, có thời gian bouncing là 5ms (<a href="https://deskthority.net/wiki/Cherry_MX">https://deskthority.net/wiki/Cherry_MX</a>), nếu viết firmware cho mọi thể loại switch thì chúng ta cần một giải pháp rộng hơn để có thể cover hết mọi thứ. <a href="#fnref6" class="footnote-backref">↩</a></p>
</li>
</ol>
</section>
<div class='other-tags'><b>Tags:</b> <a class='topic-tag' href='../tags/hardware.html'>hardware</a><a class='topic-tag' href='../tags/hacking.html'>hacking</a><a class='topic-tag' href='../tags/keyboard-building.html'>keyboard-building</a></div>
<div class="related-posts" style="margin-top: 15px; border-bottom: 1px solid #eee;">
<p><i class="em em-sun_with_face"></i> Cảm ơn bạn đã theo dõi bài viết! các bạn có thể <a href="https://facebook.com/thefullsnackblog" target="_blank">follow mình trên Facebook</a> để đặt câu hỏi, hoặc nhận thông tin về các bài viết mới.</p>
</div>
<div class="comments">
<ul id="comment-list" class="comment-list"></ul>
<div id="login-box" class="login">
Bạn nghĩ như thế nào về bài viết này?<br /><button onclick="login()">Tham gia bình luận</button>
<div class="copyright">Chức năng này cần liên kết với tài khoản Google<br />Nếu không thích thì có thể comment <button onclick="goninja()">Nặc danh</button></div>
</div>
<div id="comment-box" class="comment-input">
<div class="avatar">
<img id="user-avatar" src="#" width="32" height="32" />
</div>
<div class="input">
<textarea id="comment-content" onkeydown="submitComment(event)" placeholder="Comment gõ vào đây :D"></textarea>
<span>Gõ xong nhấn <kbd>Ctrl</kbd> + <kbd>Enter</kbd> để gửi. Bạn không thể xóa comment sau khi gửi.</span>
<button id="comment-button" onclick="submitData()">Gửi</button>
</div>
</div>
</div>
</div>
</div>
<div class="footer lightweight-theme">
<p>you're free to use the content on this blog for whatever you want</p>
<p>Created with <i class="em em-coffee"></i> <a href="https://github.com/huytd/ristretto-rs">ristretto.rs</a></p>
</div>
<script src="../js/highlight.pack.js"></script>
<script>
        </script>
<script type="text/javascript" async src="../../cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJaxb198.js?config=TeX-MML-AM_CHTML"></script>
<script type="text/x-mathjax-config">
         MathJax.Hub.Config({
             tex2jax: {
                 inlineMath: [['$','$'], ['\\(','\\)']],
                 skipTags: ["script","noscript","style","textarea", "code"],
                 ignoreClass: "tex2jax_ignore|comment|comment-list|content"
             }
         });
        </script>
<script src="../js/toc.js"></script>
<script src="../../www.gstatic.com/firebasejs/3.8.0/firebase.js"></script>
<script>
         let postCommentURL = '../api/post/mechkeyboard-second-part.json';
         // Initialize Firebase
         var config = {
             apiKey: "AIzaSyA1PnIAlJJ-U6iQJMNnCOknBuziBqGMYcY",
             authDomain: "huys-blog-comment.firebaseapp.com",
             databaseURL: "https://huys-blog-comment.firebaseio.com",
             projectId: "huys-blog-comment",
             storageBucket: "huys-blog-comment.appspot.com",
             messagingSenderId: "317330376829"
         };

         var login = function() {
             window.auth.signInWithPopup(provider)
                   .then(function(result) {
                   }).catch(function(err) {
                   });
         };

         var goninja = function() {
             updateAuth({
                 displayName: "Không Tên",
                 photoURL: "https://thefullsnack.com/img/kaonashi.jpg"
             });
         };

         var updateAuth = function(user) {
             if (user) {
                 currentUser = user;
                 // Logged in
                 document.getElementById("login-box").style.display = "none";
                 document.getElementById("comment-box").style.display = "flex";
                 document.getElementById("user-avatar").setAttribute("src", user.photoURL + "?sz=32");
             } else {
                 // Not login yet
                 document.getElementById("comment-box").style.display = "none";
                 document.getElementById("login-box").style.display = "block";
             }
         };

         var encodeHTML = function(s) {
             return s.replace(/</g, '&lt;').replace(/"/g, '&quot;').replace(/>/g, '&gt;');
         };

         var saveNewComment = function(comment) {
             if (!currentUser) {
                 return;
             }
             var commentData = {
                 username: currentUser.displayName,
                 avatar: currentUser.photoURL,
                 post_time: ~~((new Date()).getTime() / 1000),
                 message: encodeHTML(comment)
             };

             fetch(postCommentURL, {
                 method: 'post',
                 headers: {
                     "Content-Type": "application/json"
                 },
                 body: JSON.stringify(commentData)
             }).then((result) => {
                 if (result.status === 200) {
                     addNewComment(commentData.username, commentData.avatar, commentData.post_time, commentData.message);
                 }
             });

             document.getElementById("comment-content").value = "";
         };

         function debounce(func, wait, immediate) {
             var timeout;
             return function() {
                 var context = this, args = arguments;
                 var later = function() {
                     timeout = null;
                     if (!immediate) func.apply(context, args);
                 };
                 var callNow = immediate && !timeout;
                 clearTimeout(timeout);
                 timeout = setTimeout(later, wait);
                 if (callNow) func.apply(context, args);
             };
         };

         var submitData = debounce(function() {
             var comment = document.getElementById("comment-content").value;
             if (comment.length) {
                 saveNewComment(comment);
             }
         }, 250);

         var submitComment = function(e) {
             var keyCode = e.which || e.keyCode;
             var ctrlCode = e.ctrlKey || e.metaKey;
             if (keyCode === 13 && ctrlCode) {
                 submitData();
             }
         };

         var filterNewlineInComment = function(t) {
             return t.replace(/\n/g, "<br/>");
         };

         var filterURLinComment = function(comment) {
             return comment.replace(/(https?:\/\/(?:www\.|(?!www))[a-zA-Z0-9][a-zA-Z0-9-]+[a-zA-Z0-9]\.[^\s]{2,}|www\.[a-zA-Z0-9][a-zA-Z0-9-]+[a-zA-Z0-9]\.[^\s]{2,}|https?:\/\/(?:www\.|(?!www))[a-zA-Z0-9]\.[^\s]{2,}|www\.[a-zA-Z0-9]\.[^\s]{2,})/g, "<a target='_blank' rel='noopener noreferrer' href='$1'>$1</a>");
         };

         var addNewComment = function(user, avatar, time, comment, first) {
             var commentFiltered = encodeHTML(comment);
             commentFiltered = filterNewlineInComment(filterURLinComment(commentFiltered));
             commentFiltered = commentFiltered.replace(/```/g, '');
             var d = new Date(time * 1000);
             var commentTime = d.toLocaleTimeString() + ' ' + d.toLocaleDateString();
             var anoNameClass = (avatar.indexOf('thefullsnack.com') !== -1) ? "grey" : "";
             var html = '<div class="avatar">' +
                        '   <img src="' + avatar + '?sz=32" width="32" height="32"/>' +
                        ' </div>' +
                        '<div class="comment">' +
                        '  <div class="metadata"><b class="' + anoNameClass + '">' + encodeHTML(user) + '</b> lúc <span>' + commentTime + '</span></div>' +
                        '  <div class="content tex2jax_ignore">' + commentFiltered
             '  </div>' +
                        '</div>';
             var li = document.createElement('li');
             li.innerHTML = html;
             if (!first) {
                 document.getElementById("comment-list").append(li);
             } else {
                 let elm = document.getElementById("comment-list");
                 elm.insertBefore(li, elm.firstChild);
             }
         };



         window.onload = function() {

             document.querySelectorAll("pre code").forEach(el => {
                 hljs.highlightBlock(el);
             });

             start_toc_module();

             firebase.initializeApp(config);
             window.provider = new firebase.auth.GoogleAuthProvider();
             window.auth = firebase.auth();
             window.currentUser = null;

             window.auth.onAuthStateChanged(function(user) {
                 updateAuth(user);
             });


             // Fetch comment and put to posts
             fetch(postCommentURL)
                 .then(res => res.json())
                 .then(data => {
                     if (data.comments) {
                         let comments = data.comments;
                         comments.sort((a, b) => a.post_time - b.post_time);
                         for (let i = 0; i < comments.length; i++) {
                             let cmt = comments[i];
                             addNewComment(cmt.username, cmt.avatar, cmt.post_time, cmt.message);
                         }
                     }
                 });
         };

         var toggle_wordwise = function(status) {
             var book = document.querySelector("book");
             var on = document.querySelector("#ww_on");
             var off = document.querySelector("#ww_off");
             if (!status) {
                 book.className = "off";
                 on.className = "btn-toggle";
                 off.className = "btn-toggle active";
             } else {
                 book.className = "";
                 on.className = "btn-toggle active";
                 off.className = "btn-toggle";
             }
         };
        </script>
</body>

<!-- Mirrored from thefullsnack.com/posts/mechkeyboard-second-part.html by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 12 May 2020 03:19:16 GMT -->
</html>
