<html>

<!-- Mirrored from thefullsnack.com/posts/mechkeyboard-third-part.html by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 12 May 2020 03:19:09 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf8" /><!-- /Added by HTTrack -->
<head>
<title>Keyboard from Scratch: Từ A tới Z | Huy's Blog</title>
<meta charset="utf-8">
<meta http-equiv="content-type" content="text/html;"><meta name=viewport content="initial-scale=1.0 maximum-scale=1.0">
<meta property='og:image' content='img/mech-3/final-keyboard.jpg'>
<link rel="apple-touch-icon" sizes="180x180" href="../apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="../favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="../favicon-16x16.png">
<link rel="manifest" href="../manifest.json">
<link rel="mask-icon" href="../safari-pinned-tab.svg" color="#5bbad5">
<meta name="theme-color" content="#ffffff">
<link href="../css/theme.dist.css" rel="stylesheet" type="text/css">
<link rel="stylesheet" href="../emoji/css/emoji.dist.css">
<link href="https://fonts.googleapis.com/css?family=Open+Sans:400,700|Space+Mono:400,700&amp;display=swap&amp;subset=vietnamese" rel="stylesheet">

<script async src="https://www.googletagmanager.com/gtag/js?id=UA-92158965-1"></script>
<script>
	       window.dataLayer = window.dataLayer || [];
	       function gtag(){dataLayer.push(arguments);}
	       gtag('js', new Date());

	       gtag('config', 'UA-92158965-1');
	      </script>
</head>
<body lang="en" class="post">
<div class="header lightweight-theme">
<a href="../index.html"><span class="avatar"></span></a>
</div>
<div class="container">
<div class="main">
<h1><span>Keyboard from Scratch: Từ A tới Z</span></h1>
<p>Sau khi kết thúc <a href="../tags/keyboard-building.html">hai phần trước</a>, chúng ta đã có những kiến thức cơ bản về chiếc bàn phím cơ, không để các bạn đợi lâu, ở phần này chúng ta sẽ thực sự bắt tay vào làm một chiếc bàn phím hoàn chỉnh.</p>
<p><strong>TL;DR:</strong> Các bước để build một chiếc bàn phím cơ</p>
<ol>
<li>Tham khảo thật nhiều layout, thiết kế của cộng đồng</li>
<li>Thiết kế cho mình một layout hợp lý</li>
<li>Đặt mua linh kiện, keycaps, switches, cắt plate nếu cần thiết</li>
<li>Hàn mạch bằng tay, hoặc thiết kế mạch in rồi mới hàn</li>
<li>Hàn controller, viết firmware hoặc modify từ các firmware có sẵn như QMK hay TMK</li>
<li>Done</li>
</ol>
<hr />
<p>Trước khi bắt đầu thì các bạn hãy để mình khoe hàng tí đã, chiếc bàn phím bốn chấm không, à nhầm 40% mang tên <strong>SnackyMini Keyboard</strong> <i class='em em-think-hopeful'></i> một sản phẩm kết tinh của tinh thần bốn chấm không, của trí tuệ Việt và nền công nghệ tiên tiến của Đế quốc Tư bản Huê Kỳ, cộng với nguồn cung cấp thiết bị kĩ thuật, linh kiện bán dẫn phong phú của người anh lớn Trung Hoa, một sản phẩm của người Việt, dành cho cả người Việt lẫn người không Việt, được nghiên cứu, thiết kế và tối ưu dành riêng cho các software developer, một... ấy ấy ấy, thôi các bạn đừng tắt mà, ở lại đọc tiếp đi mà, mình im rồi đây <i class='em em-joy'></i></p>
<img src="img/mech-3/final-keyboard.jpg" style="max-width: 800px; margin-left: -140px;" />
<p>Bài viết sẽ mang tính chất ghi chép lại quá trình mình thực hiện chiếc bàn phím, một số yếu tố kĩ thuật sẽ được lượt bỏ hoặc tối giản, phun ra mà không có giải thích hay chú thích, nên có thể bài viết sẽ có những đoạn khó hiểu. Nếu sau khi đọc xong series bài viết này và các bạn có ý định tự mình làm một chiếc bàn phím cơ, và có thắc mắc, xin đừng ngại comment hoặc để lại lời nhắn, mình sẽ cố gắng trả lời trong phạm vi hiểu biết của bản thân.</p>
<h2><a href="#thiết-kế-layout" aria-hidden="true" class="anchor" id="thiết-kế-layout"></a>Thiết kế layout</h2>
<p>Việc đầu tiên cần làm khi bắt đầu bất kì một dự án nào đó là thiết kế. Chúng ta cần phải thiết kế bố cục (layout) <span class="sidenote mute">Làm phần cứng không giống như phần mềm, chỉ cần một sai sót nhỏ trong bố cục hoặc một điểm bất hợp lý trong thiết kế thì chúng ta phải trả giá bằng cả thời gian lẫn tiền bạc và công sức, các sai lầm thường rất khó hoặc là không thể sửa chữa, làm lại.</span> của chiếc bàn phím, bước này rất quan trọng và đòi hỏi bạn phải tham khảo thật nhiều, suy nghĩ một cách thật kĩ lưỡng để chọn được một bố cục và thiết kế ưng ý.</p>
<p>Nếu chưa biết mình muốn gì, thì các bạn có thể tham khảo qua các mẫu bàn phím khác nhau trên các cộng đồng dân chơi phím cơ như <a href="https://www.reddit.com/r/MechanicalKeyboards/">Reddit /r/MechanicalKeyboards</a>, <a href="https://geekhack.org/index.php?board=178.0">Geekhack</a>, <a href="https://deskthority.net/viewforum.php?f=62&amp;sid=feb51050d8448b8afb108c05f64ab5aa">Deskthority</a>, trên những cộng đồng này cũng thường xuyên có những thảo luận về việc tự build bàn phím, rất hữu ích. Ngoài ra thì còn nhiều cộng đồng khác, ví dụ như <a href="https://www.facebook.com/groups/VietNamMechKey/">VietnamMechKey</a>.</p>
<p>Ý tưởng của mình là thiết kế bộ chiếc bàn phím có layout 40% nên cũng đã tham khảo nhiều từ trang <a href="http://www.40percent.club/">40percent.club</a>. Một số yêu cầu thiết kế của mình tự đặt ra là như sau:</p>
<ul>
<li>Sau một thời gian xài layout 60% thì mình thấy dù sao bàn phím có hàng phím mũi tên vẫn tiện hơn cả, vì thế chiếc bàn phím nhỏ gọn sắp build cũng phải có 4 phím mũi tên.</li>
<li>Tiếp theo, vì công việc chính của mình là code, nên để có thể sử dụng chiếc bàn phím này hằng ngày, thì mình vẫn phải giữ lại các phím cơ bản hay dùng như <code>[ ] ( ) { } ; : &lt; &gt; , .</code>, hoặc <code>Tab</code>.</li>
<li>Sau một thời gian sử dụng Emacs thì mình sử dụng phím <code>Ctrl</code> khá thường xuyên, vì thế phím này cần phải đặt ở một vị trí nào đó cho tiện bấm nhất.</li>
<li>Cụm phím <code>Cmd</code>, <code>Alt</code>, <code>Shift</code> bên phía tay phải mình chưa một lần nào phải đụng tới trong suốt bao nhiêu năm xài máy tính, nên tốt nhất là vứt nó đi.</li>
<li>Layout vừa nhỏ nên sẽ không đủ chỗ để đặt hàng phím số vào, cho nên tốt hơn cả là giấu nó vào hàng phím <code>QWERTY</code> thông qua một phím <code>Fn</code>, khi nhấn phím này thì bàn phím sẽ chuyển qua layout phím số.</li>
</ul>
<p>Sau khi quyết định xong các yêu cầu trên, thì mình bắt tay vào thiết kế layout bằng trang web <a href="http://www.keyboard-layout-editor.com/">http://www.keyboard-layout-editor.com</a>, layout có dạng tương tự như bàn phím <a href="https://www.massdrop.com/buy/minivan-keyboard">Minivan Arrow</a>:</p>
<p>Bàn phím mặc định ở trên, và bàn phím khi nhấn nút <code>Fn</code> ở dưới:</p>
<p><img src="img/mech-3/keyboard-layout.png" alt="" /></p>
<p>Sau khi kết thúc bước này, các bạn có thể export layout này ra định dạng JSON và đưa qua <a href="http://builder.swillkb.com/">http://builder.swillkb.com/</a> để thiết kế plate và case, nếu các bạn có ý định làm bàn phím plate mount. Ở đây mình chỉ xài PCB mount nên bỏ qua bước này.</p>
<p>Ngoài ra, bạn còn có thể vào tab Summary để xem danh sách và số lượng các phím cần dùng, ví dụ đây là danh sách các phím cần dùng cho layout của mình:</p>
<p><img src="img/mech-3/keyboard-summary.png" alt="" /></p>
<h2><a href="#thiết-kế-mạch-in" aria-hidden="true" class="anchor" id="thiết-kế-mạch-in"></a>Thiết kế mạch in</h2>
<p>Đến đây, chúng ta đã có layout, bước tiếp theo là thiết kế mạch in (PCB) để hàn các linh kiện vào. Thực ra việc này đối với nhiều người khó hơn là hàn mạch bằng tay (handwired), với mình thì... trước đây mình cũng đã làm một bản prototype handwired, tuy nhiên nhờ kĩ năng hàn mạch thần sầu, mình nướng chín luôn hầu hết diode trên mạch <i class='em em-joy'></i> và cuối cùng thì bản này bị vứt xó.</p>
<p><img src="img/mech-3/failed-matrix.jpg" alt="" /></p>
<p>Sau khi xem xét nhiều phương án, thì việc tự thiết kế PCB là khả thi nhất, vì như thế đến công đoạn hàn linh kiện vào đỡ vất vả hơn, và giảm thiểu được tối đa nguy cơ xảy ra lỗi. Mỗi tội tốn tiền nhiều hơn.</p>
<p>Để thiết kế PCB thì mình dùng phần mềm <a href="http://kicad-pcb.org/">KiCad</a> vì nó trực quan, đầy đủ nhiều chức năng, có khả năng render ra board mạch hoàn chỉnh trông rất đẹp, open source và miễn phí, và quan trọng nhất là đa số các cơ sở sản xuất mạch đều hỗ trợ định dạng file của KiCad.</p>
<p>Cái khó nhất khi dùng KiCad là giao diện của nó không được thông minh cho lắm, hay nói thẳng ra nó luôn là giao diện ngu như <i class='em em-poop'></i>. Đặc biệt là trên macOS. Đó là chưa kể cơ chế quản lý thư viện footprint và component của nó khá rối. Trước khi bắt tay vào làm thì các bạn nên đọc qua <a href="https://deskthority.net/wiki/KiCAD_keyboard_PCB_design_guide">bài hướng dẫn sử dụng của Deskthority</a>, đây là bài viết dễ hiểu nhất mà mình có thể tìm thấy, mặc dù hơi cũ.</p>
<p>Cái khó thứ hai, là bắt đầu như thế nào? một cái switch có những chân nào, cần đục những lỗ nào? khoảng cách giữa các switch là bao xa? để nắm được các thông tin này thì bạn cần phải bới tung các wiki và các diễn đàn về phím cơ lên. Ở đây mình sẽ nói sơ qua, vì các bạn có đọc trước cũng không thể nhớ được cho tới khi các bạn bắt tay vô làm và tự mình đụng phải các vấn đề đó <i class='em em-joy'></i></p>
<ul>
<li>
<p>Về chân switch (footprint) và các linh kiện khác, các bạn có thể tải thư viện hỗ trợ cho KiCad tại đây <a href="https://github.com/tmk/keyboard_parts.pretty">https://github.com/tmk/keyboard_parts.pretty</a> và đây <a href="https://github.com/tmk/kicad_lib_tmk">https://github.com/tmk/kicad_lib_tmk</a>. Đồng thời tham khảo bài viết này để biết cách import <a href="https://github.com/ruiqimao/keyboard-pcb-guide">https://github.com/ruiqimao/keyboard-pcb-guide</a>.</p>
</li>
<li>
<p>Về khoảng cách giữa các chân switch, thì theo tài liệu của hãng Cherry, mỗi switch có kích thước <code>15.6mm x 15.6mm</code>, keycaps có kích thước tầm <code>18mm x 18mm</code> nữa, <a href="https://deskthority.net/viewtopic.php?p=327503#p327503">theo matt3o</a>, khi kết hợp lại thì mỗi một switch <code>1u</code> nên chiếm một ô có kích thước <code>19.05mm x 19.05mm</code>.</p>
<p><img src="img/mech-3/switch-pcb-distance.png" alt="" /></p>
<p>Một hình vuông màu đen như trên là footprint cho một phím/switch đã kèm cả key caps (<code>1u</code>). Hai phím <code>1u</code> kề nhau sẽ có footprint kề cạnh nhau, và khoảng cách giữa hai phím như thế này đủ để đặt vào một con diode (kí hiệu D39 như trong hình).</p>
</li>
</ul>
<p>À, cũng phải nói thêm, mình sử dụng Teensy 3.2 làm controller cho chiếc bàn phím này, vì lý do nó dễ mua, dễ lập trình, hỗ trợ giao tiếp với máy tính như là một thiết bị USB, và có sẵn bộ thư viện Teensyduino xài khá tiện.</p>
<p>Sau vài ngày hì hục với KiCad thì đây là thành quả, nhìn rối như tơ vò, nhưng là một cái PCB 2 mặt:</p>
<img src="img/mech-3/pcb.png" style="max-width: 800px; margin-left: -140px;" />
<p>Ngày xưa mình từng có thời gian tự làm PCB trên miếng đồng bằng máy in laser, giấy màu, bàn ủi, bàn chải đánh răng và thuốc sắt FeCl3, chưa bao giờ mình dám mơ tới chuyện làm một cái PCB có đường mạch mỏng hơn 2mm, chứ đừng nói tới một cái PCB 2 mặt.</p>
<p>Quên nói, 4 cái lỗ ở 4 góc board có đường kính <code>2.5mm</code>, vừa đủ cho một con M2 standoff cắm vào.</p>
<p>Sau khi hoàn thành, thì mình hí hửng xuất file ra và gửi cho nhà in, đây là một công ty ở Trung Quốc, sở dĩ chọn Trung Quốc là vì hôm đó ngày lễ ở Mỹ, không có nhà in nào của Mỹ làm việc cả.</p>
<p>Có bạn hỏi muốn biết thêm chi tiết về công đoạn này, thì như thế này: Khi làm việc với các công ty in mạch, bạn sẽ phải gửi file cho họ, bạn có thể nén và gửi toàn bộ project KiCad cho họ, hoặc đơn giản hơn thì có thể xuất project ra thành nhiều file gerber (mỗi một file gerber sẽ là một layer của board, ví dụ layer mạch đồng, layer khoan lỗ, layer hình vẽ trên mạch,...) rồi nén tất cả lại thành một file zip để gửi. Trong repo Github ở cuối bài, mình có để sẵn file <code>snackymini-manufacturing-submission.zip</code> trong thư mục <code>hardware</code>, chứa các file gerber này, có thể gửi trực tiếp file này tới nhà in. Còn dịch vụ mình sử dụng là công ty <strong>JLCPCB</strong>, họ có đội ngũ support rất tận tình, trao đổi và confirm qua mail liên tục, mỗi tội tiếng Anh của các bạn này hơi bị dỏm, được cái giá cả khá ổn và thời gian gia công khá nhanh.</p>
<p>Vì nôn nóng nên mình chọn in gấp, chỉ tốn 2 ngày gia công và 3 ngày để mấy cái mạch bơi từ bên đó qua bên đây, tầm 50 USD ra đi cho 10 cái board mạch đen cóng ngầu xì dầu:</p>
<img src="img/mech-3/pcb-result.jpg" style="max-width: 800px; margin-left: -140px;" />
<p>Trong thời gian chờ in mạch thì mình cũng đặt mua luôn các linh kiện cần thiết, bao gồm:</p>
<ul>
<li>1 board mạch Teensy 3.2 loại có hàn sẵn header</li>
<li>50 switch Cherry MX Black</li>
<li>100 diode 1N4148</li>
<li>Keycaps thì đã có sẵn, gom góp lại cũng đủ quân số, mặc dù lố nhố</li>
</ul>
<p>Hầu hết các phím mình dùng đều không quá <code>2.5u</code>, và cũng quên không đục lỗ cắm stabilizer, nên mình bỏ qua nó luôn, gõ thấy cũng hơi kì kì nhưng kệ đi.</p>
<p>Việc tiếp theo là lôi switches và diodes ra hàn, mình dùng Cherry Black, ban đầu gõ thấy khá nặng vì đã quen xài Brown, nhưng dần cũng quen.</p>
<img src="img/mech-3/pcb-switches.jpg" style="max-width: 800px; margin-left: -140px;" />
<p>Hàn controller vô mặt sau, ở đây thì có một vấn đề, đó là vì sợ Teensy sẽ đụng vào switch, mình phải dùng header để tạo ra khoảng cách, và hàn ngược con Teensy lại cho phần chân cắm vào phần bụng của PCB, điều này sai với thiết kế ban đầu. Rất may lỗi này có thể khắc phục được bằng phần mềm:</p>
<img src="img/mech-3/pcb-controller.jpg" style="max-width: 800px; margin-left: -140px;" />
<p>Hàn xong đâu ra đấy thì mới thấy khi thiết kế mạch, mình quá cẩn thận khi đã dành ra một phần diện tích khá lớn cho viền ngoài của board, về sau khi xem mạch thực tế và xem các bản thiết kế khác thì khá tiếc, vì đáng ra không có phần viền, bàn phím trông sẽ gọn gàng hơn.</p>
<p>Đâu ra đấy xong thì lắp key caps vào:</p>
<img src="img/mech-3/keycap.jpg" style="max-width: 800px; margin-left: -140px;" />
<p>Thế là xong phần cứng. Tiếp theo là đến firmware.</p>
<h2><a href="#viết-firmware" aria-hidden="true" class="anchor" id="viết-firmware"></a>Viết Firmware</h2>
<p>Nếu các bạn không đọc các bài trước, thì lý do mình quyết định tự viết firmware chỉ đơn giản là vì mình không compile được các firmware có sẵn như QMK hay TMK cho Teensy 3.2 <i class='em em-think-cry'></i> nếu các bạn sử dụng controller khác, có thể các bạn sẽ compile được và không cần phải đâm đầu vào con đường đen tối này. Suy cho cùng, tự viết firmware cũng có cái hay của nó, và mình học được rất nhiều từ việc này. Dưới đây là một vài ghi chép của mình trong quá trình viết, nếu không thực sự quan tâm, các bạn có thể bỏ qua cũng được.</p>
<p>Mãi cho đến khi hoàn thành xong phần hardware thì mình mới bắt tay vào viết firmware hoàn chỉnh (chứ không phải là cái firmware điều khiển 4 nút như trong bài trước). Về cơ bản thì không khác nhiều mấy so với trong bài trước, mình dùng một mảng kiểu <code>unit8_t</code> để lưu thông tin về layout bàn phím, đây là một mảng 3 chiều, nó gồm có 2 mảng 2 chiều, mỗi một mảng 2 chiều là một layout:</p>
<pre><code class="language-c">uint8_t keyLayout[][ROWS][COLS] = {
  // Default layout
  {
   { KEY_TAB  , KEY_Q   , KEY_W   , KEY_E   , KEY_R   , KEY_T   , KEY_Y   ,...
   { NULL_KEY , KEY_A   , KEY_S   , KEY_D   , KEY_F   , KEY_G   , KEY_H   ,...
   { NULL_KEY , KEY_Z   , KEY_X   , KEY_C   , KEY_V   , KEY_B   , KEY_N   ,...
   { KEY_TILDE, NULL_KEY, NULL_KEY, NULL_KEY, NULL_KEY, NULL_KEY, NULL_KEY,...
  },
  // Fn layout
  {
   { KEY_ESC , KEY_1   , KEY_2   , KEY_3   , KEY_4   , KEY_5   , KEY_6   ,...
   { NULL_KEY, NULL_KEY, NULL_KEY, NULL_KEY, NULL_KEY, NULL_KEY, NULL_KEY,...
   { NULL_KEY, NULL_KEY, NULL_KEY, NULL_KEY, NULL_KEY, NULL_KEY, NULL_KEY,...
   { NULL_KEY, NULL_KEY, NULL_KEY, NULL_KEY, NULL_KEY, NULL_KEY, NULL_KEY,...
  }
};
</code></pre>
<p>Code cho việc chuyển layout bằng phím <code>Fn</code>:</p>
<pre><code class="language-c">if (keys[i].code == FN_KEY) {
  layoutId = FN_LAYOUT; break;
}
submitLayout(keys, keyLayout[layoutId]);
</code></pre>
<p>Một thay đổi nữa so với bài viết trước, đó là thuật toán debounce, sau khi thử nghiệm và tham khảo từ các firmware khác, thì mình quyết định làm đơn giản hơn, giống với các firmware phổ biến như QMK/TMK, là quét từng đợt sau mỗi 15 milli giây, đơn giản đến không đỡ được:</p>
<pre><code class="language-c">#define DEBOUNCE_DELAY 15

void loop()
{
  unsigned long timeNow = millis();
  if (timeNow - lastFrame &gt; DEBOUNCE_DELAY) {
    lastFrame = timeNow;
    // Scan key
  }
}
</code></pre>
<p>Khi compile và upload firmware vào bàn phím, ban đầu thì mọi thứ có vẻ hoạt động rất trơn tru, nhưng khi mình thử gõ một đoạn nội dung dài vào, thì xảy ra tình trạng mất phím, ví dụ gõ:</p>
<blockquote>
<p>Hello I am Huy</p>
</blockquote>
<p>thì lại thành ra:</p>
<blockquote>
<p>Helo I m Hy</p>
</blockquote>
<p>Thế là tốn thêm 1 ngày để debug, nguyên nhân thì hết sức ngớ ngẩn <i class='em em-joy'></i> vì trong lúc viết firmware, mình lười và chỉ làm cho cái bàn phím đọc mỗi một phím duy nhất ở một thời điểm, và khi gõ nhanh, ở một thời điểm có thể sẽ có rất nhiều phím được nhấn xuống. Cũng nhờ thế mà lại biết thêm được khái niệm <strong>NKRO</strong> (n-key roll over), một chức năng giúp cho bàn phím có thể ghi nhận được nhiều phím trong một thời điểm. Đối với các bàn phím sử dụng cổng USB, thì tối đa chi ghi nhận được 6 phím, trong khi đó bàn phím dùng cổng PS/2 thì xả láng.</p>
<p>Việc implement chức năng này cũng không mấy khó khăn, nhờ các hàm <code>Keyboard.set_key1</code>, <code>Keyboard.set_key2</code>, <code>Keyboard.set_key3</code>,... của Teensyduino. Về ý tưởng thì ở mỗi lần quét, mình tạo một mảng gồm 6 phần tử để lưu lần lượt giá trị các phím nhận được:</p>
<pre><code class="language-c">#define MAXIMUM_STROKES 6

struct Key* readKey() {
  struct Key* result = (Key*)malloc(MAXIMUM_STROKES * sizeof(struct Key));
  int currentFinger = 0;

  for (int row = 0; row &lt; ROWS; row++) {
    for (int col = 0; col &lt; COLS; col++) {
      if (keyPressedAt(row, col)) {
        result[currentFinger].row = row;
        result[currentFinger].col = col;
        if (currentFinger &lt; MAXIMUM_STROKES) currentFinger++;
      }
    }
  }

  return result;
}
</code></pre>
<p>Rồi sau đó lần lượt sử dụng các hàm <code>Keyboard.set_key&lt;x&gt;</code> để gán giá trị cho từng phím, và gửi đi một lần bằng hàm <code>Keyboard.send_now()</code>:</p>
<pre><code class="language-c">void submitLayout(struct Key* keys, uint8_t layout[ROWS][COLS]) {
  int currentFinger = 0;
  ...
  for (int i = 0; i &lt; SUPPORTED_STROKES; i++) {
    int c = layout[pos.r][pos.c];
    if (c != NULL_KEY) {
      setKey(currentFinger, c);
      currentFinger++;
    }
  }
  ...
  Keyboard.send_now();
}
</code></pre>
<p>Một số bàn phím còn cho phép người dùng tự cấu hình layout bằng phần mềm trên máy tính, xét ở góc độ firmware, điều này không quá khó, chỉ việc chuyển mảng <code>keyLayout</code> về một cấu trúc khác có thể lưu được vào bộ nhớ của Teensy, từ đó ta có thể load ra mỗi khi bàn phím được khởi động. Ví dụ <a href="https://www.pjrc.com/teensy/td_libs_EEPROM.html">lưu vào EEPROM</a> thông qua hàm <code>EEPROM.read()</code> và <code>EEPROM.write()</code>, tuy nhiên cần lưu ý, EEPROM của Teensy 3.2 chỉ có 2KB, hơi ít, nhưng chắc vừa đủ xài. Nhưng nếu đã tự build được firmware, thì chả cần làm vậy cho mất công, chỉ cần customize layout bằng cách customize luôn source code <i class='em em-joy'></i></p>
<p>Mấy hôm nay ngồi xem kĩ lại firmware QMK, thấy nó <a href="https://beta.docs.qmk.fm/features">có vài features khá thú vị</a>, như Grave Escape Key, Key Lock, Tap Dance hay Mouse Key,... hôm nào có thời gian mình sẽ ngồi clone lại và viết thêm về chủ đề này.</p>
<p>Chỉ cần chừng đó thứ thì bạn đã có thể tự mình viết được firmware cho chiếc bàn phím của mình rồi. Nếu quan tâm, các bạn có thể tham khảo mã nguồn đầy đủ của firmware lẫn hardware cho bàn phím này tại đây <a href="https://github.com/huytd/snackymini-keyboard/">https://github.com/huytd/snackymini-keyboard/</a></p>
<hr />
<p>Xin cảm ơn các bạn đã kiên nhẫn đọc đến tận đây (tui nói vậy thôi chứ tui biết bạn scroll xuống đây từ đầu trang, chỉ tốn có 3 giây). Nếu bạn cũng là dân chơi mech, hy vọng bài viết này giúp các bạn hiểu thêm về những chiếc bàn phím tiền triệu mà mình đã mua. Nếu bạn chưa phải là dân chơi, hy vọng bài viết này làm nhụt chí và ngăn bạn lao vào con đường tốn kém này. Nếu đã đọc hết mà vẫn quyết định sẽ mua hoặc tự làm một chiếc bàn phím cơ, thì mình xin chúc mừng và chúc các bạn may mắn luôn.</p>
<p><strong>P/S:</strong> Nếu bạn nào đang ở US, thì mình còn dư vài cái PCB, nếu có hứng thú thì cứ PM mình qua Facebook, mình sẽ gửi tặng.</p>
<p>Bài viết này được gõ bằng bàn phím <strong>SnackyMini Keyboard</strong> <i class='em em-smirk'></i></p>
<div class='other-tags'><b>Tags:</b> <a class='topic-tag' href='../tags/hardware.html'>hardware</a><a class='topic-tag' href='../tags/hacking.html'>hacking</a><a class='topic-tag' href='../tags/keyboard-building.html'>keyboard-building</a></div>
<div class="related-posts" style="margin-top: 15px; border-bottom: 1px solid #eee;">
<p><i class="em em-sun_with_face"></i> Cảm ơn bạn đã theo dõi bài viết! các bạn có thể <a href="https://facebook.com/thefullsnackblog" target="_blank">follow mình trên Facebook</a> để đặt câu hỏi, hoặc nhận thông tin về các bài viết mới.</p>
</div>
<div class="comments">
<ul id="comment-list" class="comment-list"></ul>
<div id="login-box" class="login">
Bạn nghĩ như thế nào về bài viết này?<br /><button onclick="login()">Tham gia bình luận</button>
<div class="copyright">Chức năng này cần liên kết với tài khoản Google<br />Nếu không thích thì có thể comment <button onclick="goninja()">Nặc danh</button></div>
</div>
<div id="comment-box" class="comment-input">
<div class="avatar">
<img id="user-avatar" src="#" width="32" height="32" />
</div>
<div class="input">
<textarea id="comment-content" onkeydown="submitComment(event)" placeholder="Comment gõ vào đây :D"></textarea>
<span>Gõ xong nhấn <kbd>Ctrl</kbd> + <kbd>Enter</kbd> để gửi. Bạn không thể xóa comment sau khi gửi.</span>
<button id="comment-button" onclick="submitData()">Gửi</button>
</div>
</div>
</div>
</div>
</div>
<div class="footer lightweight-theme">
<p>you're free to use the content on this blog for whatever you want</p>
<p>Created with <i class="em em-coffee"></i> <a href="https://github.com/huytd/ristretto-rs">ristretto.rs</a></p>
</div>
<script src="../js/highlight.pack.js"></script>
<script>
        </script>
<script type="text/javascript" async src="../../cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJaxb198.js?config=TeX-MML-AM_CHTML"></script>
<script type="text/x-mathjax-config">
         MathJax.Hub.Config({
             tex2jax: {
                 inlineMath: [['$','$'], ['\\(','\\)']],
                 skipTags: ["script","noscript","style","textarea", "code"],
                 ignoreClass: "tex2jax_ignore|comment|comment-list|content"
             }
         });
        </script>
<script src="../js/toc.js"></script>
<script src="../../www.gstatic.com/firebasejs/3.8.0/firebase.js"></script>
<script>
         let postCommentURL = '../api/post/mechkeyboard-third-part.json';
         // Initialize Firebase
         var config = {
             apiKey: "AIzaSyA1PnIAlJJ-U6iQJMNnCOknBuziBqGMYcY",
             authDomain: "huys-blog-comment.firebaseapp.com",
             databaseURL: "https://huys-blog-comment.firebaseio.com",
             projectId: "huys-blog-comment",
             storageBucket: "huys-blog-comment.appspot.com",
             messagingSenderId: "317330376829"
         };

         var login = function() {
             window.auth.signInWithPopup(provider)
                   .then(function(result) {
                   }).catch(function(err) {
                   });
         };

         var goninja = function() {
             updateAuth({
                 displayName: "Không Tên",
                 photoURL: "https://thefullsnack.com/img/kaonashi.jpg"
             });
         };

         var updateAuth = function(user) {
             if (user) {
                 currentUser = user;
                 // Logged in
                 document.getElementById("login-box").style.display = "none";
                 document.getElementById("comment-box").style.display = "flex";
                 document.getElementById("user-avatar").setAttribute("src", user.photoURL + "?sz=32");
             } else {
                 // Not login yet
                 document.getElementById("comment-box").style.display = "none";
                 document.getElementById("login-box").style.display = "block";
             }
         };

         var encodeHTML = function(s) {
             return s.replace(/</g, '&lt;').replace(/"/g, '&quot;').replace(/>/g, '&gt;');
         };

         var saveNewComment = function(comment) {
             if (!currentUser) {
                 return;
             }
             var commentData = {
                 username: currentUser.displayName,
                 avatar: currentUser.photoURL,
                 post_time: ~~((new Date()).getTime() / 1000),
                 message: encodeHTML(comment)
             };

             fetch(postCommentURL, {
                 method: 'post',
                 headers: {
                     "Content-Type": "application/json"
                 },
                 body: JSON.stringify(commentData)
             }).then((result) => {
                 if (result.status === 200) {
                     addNewComment(commentData.username, commentData.avatar, commentData.post_time, commentData.message);
                 }
             });

             document.getElementById("comment-content").value = "";
         };

         function debounce(func, wait, immediate) {
             var timeout;
             return function() {
                 var context = this, args = arguments;
                 var later = function() {
                     timeout = null;
                     if (!immediate) func.apply(context, args);
                 };
                 var callNow = immediate && !timeout;
                 clearTimeout(timeout);
                 timeout = setTimeout(later, wait);
                 if (callNow) func.apply(context, args);
             };
         };

         var submitData = debounce(function() {
             var comment = document.getElementById("comment-content").value;
             if (comment.length) {
                 saveNewComment(comment);
             }
         }, 250);

         var submitComment = function(e) {
             var keyCode = e.which || e.keyCode;
             var ctrlCode = e.ctrlKey || e.metaKey;
             if (keyCode === 13 && ctrlCode) {
                 submitData();
             }
         };

         var filterNewlineInComment = function(t) {
             return t.replace(/\n/g, "<br/>");
         };

         var filterURLinComment = function(comment) {
             return comment.replace(/(https?:\/\/(?:www\.|(?!www))[a-zA-Z0-9][a-zA-Z0-9-]+[a-zA-Z0-9]\.[^\s]{2,}|www\.[a-zA-Z0-9][a-zA-Z0-9-]+[a-zA-Z0-9]\.[^\s]{2,}|https?:\/\/(?:www\.|(?!www))[a-zA-Z0-9]\.[^\s]{2,}|www\.[a-zA-Z0-9]\.[^\s]{2,})/g, "<a target='_blank' rel='noopener noreferrer' href='$1'>$1</a>");
         };

         var addNewComment = function(user, avatar, time, comment, first) {
             var commentFiltered = encodeHTML(comment);
             commentFiltered = filterNewlineInComment(filterURLinComment(commentFiltered));
             commentFiltered = commentFiltered.replace(/```/g, '');
             var d = new Date(time * 1000);
             var commentTime = d.toLocaleTimeString() + ' ' + d.toLocaleDateString();
             var anoNameClass = (avatar.indexOf('thefullsnack.com') !== -1) ? "grey" : "";
             var html = '<div class="avatar">' +
                        '   <img src="' + avatar + '?sz=32" width="32" height="32"/>' +
                        ' </div>' +
                        '<div class="comment">' +
                        '  <div class="metadata"><b class="' + anoNameClass + '">' + encodeHTML(user) + '</b> lúc <span>' + commentTime + '</span></div>' +
                        '  <div class="content tex2jax_ignore">' + commentFiltered
             '  </div>' +
                        '</div>';
             var li = document.createElement('li');
             li.innerHTML = html;
             if (!first) {
                 document.getElementById("comment-list").append(li);
             } else {
                 let elm = document.getElementById("comment-list");
                 elm.insertBefore(li, elm.firstChild);
             }
         };



         window.onload = function() {

             document.querySelectorAll("pre code").forEach(el => {
                 hljs.highlightBlock(el);
             });

             start_toc_module();

             firebase.initializeApp(config);
             window.provider = new firebase.auth.GoogleAuthProvider();
             window.auth = firebase.auth();
             window.currentUser = null;

             window.auth.onAuthStateChanged(function(user) {
                 updateAuth(user);
             });


             // Fetch comment and put to posts
             fetch(postCommentURL)
                 .then(res => res.json())
                 .then(data => {
                     if (data.comments) {
                         let comments = data.comments;
                         comments.sort((a, b) => a.post_time - b.post_time);
                         for (let i = 0; i < comments.length; i++) {
                             let cmt = comments[i];
                             addNewComment(cmt.username, cmt.avatar, cmt.post_time, cmt.message);
                         }
                     }
                 });
         };

         var toggle_wordwise = function(status) {
             var book = document.querySelector("book");
             var on = document.querySelector("#ww_on");
             var off = document.querySelector("#ww_off");
             if (!status) {
                 book.className = "off";
                 on.className = "btn-toggle";
                 off.className = "btn-toggle active";
             } else {
                 book.className = "";
                 on.className = "btn-toggle active";
                 off.className = "btn-toggle";
             }
         };
        </script>
</body>

<!-- Mirrored from thefullsnack.com/posts/mechkeyboard-third-part.html by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 12 May 2020 03:19:12 GMT -->
</html>
