<html>

<!-- Mirrored from thefullsnack.com/posts/vim-play-with-floating.html by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 12 May 2020 03:18:59 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf8" /><!-- /Added by HTTrack -->
<head>
<title>Cách mạng 0.4 của Neovim: Floating Window | Huy's Blog</title>
<meta charset="utf-8">
<meta http-equiv="content-type" content="text/html;"><meta name=viewport content="initial-scale=1.0 maximum-scale=1.0">
<meta property='og:image' content='img/vim-float-term/avatar.jpg'>
<link rel="apple-touch-icon" sizes="180x180" href="../apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="../favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="../favicon-16x16.png">
<link rel="manifest" href="../manifest.json">
<link rel="mask-icon" href="../safari-pinned-tab.svg" color="#5bbad5">
<meta name="theme-color" content="#ffffff">
<link href="../css/theme.dist.css" rel="stylesheet" type="text/css">
<link rel="stylesheet" href="../emoji/css/emoji.dist.css">
<link href="https://fonts.googleapis.com/css?family=Open+Sans:400,700|Space+Mono:400,700&amp;display=swap&amp;subset=vietnamese" rel="stylesheet">

<script async src="https://www.googletagmanager.com/gtag/js?id=UA-92158965-1"></script>
<script>
	       window.dataLayer = window.dataLayer || [];
	       function gtag(){dataLayer.push(arguments);}
	       gtag('js', new Date());

	       gtag('config', 'UA-92158965-1');
	      </script>
</head>
<body lang="en" class="post">
<div class="header lightweight-theme">
<a href="../index.html"><span class="avatar"></span></a>
</div>
<div class="container">
<div class="main">
<h1><span>Cách mạng 0.4 của Neovim: Floating Window</span></h1>
<p>Trước khi bắt đầu: Nếu vì lý do gì đó mà bạn quyết định không đọc bài viết này vì bạn đang xài VSCode và thấy nó đủ xịn với bạn rồi, thì hãy suy nghĩ lại, đọc <a href="vim-setup-2019.html">bài này</a>, và tải về <a href="https://github.com/huytd/vim-config">phiên bản Vim mình đã build</a>. Nó không chỉ có mọi thứ hay ho mà VSCode có, mà còn có nhiều thứ khác xịn hơn mà VSCode không hề có.</p>
<hr />
<p>Neovim từ phiên bản 0.4 có một chức năng cực kì hay ho đó là <code>floating windows</code>, giúp hiển thị một buffer ở bất kì vị trí nào trên màn hình. Nên nhớ là chúng ta đang nói đến Neovim, một editor hoạt động trên terminal, nơi mà mọi thứ chỉ là text và không hề có các khái niệm về giao diện đồ họa.</p>
<p>Sau khi chức năng này được release thì cộng đồng Neovim đã adopt nó khá nhanh, rất nhiều plugin áp dụng nó khá hiệu quả ví dụ như <a href="https://github.com/neoclide/coc.nvim">coc.nvim</a> hay <a href="https://github.com/Shougo/denite.nvim/">denite.nvim</a>.</p>
<p>Trong bài viết này, chúng ta sẽ cùng tìm hiểu về floating window thông qua việc build một chức năng giúp cho Neovim có thể mở nhanh một cửa sổ terminal emulator, nằm floating trên màn hình. Mình thường dùng chức năng này khi cần thực hiện nhanh một thao tác nào đó như tạo git branch, push hoặc pull code mà lười xài Tmux.</p>
<img src="img/vim-float-term/demo.gif" style="max-width: 750px; margin-left: -100px" />
<h2><a href="#tìm-hiểu-api-của-neovim" aria-hidden="true" class="anchor" id="tìm-hiểu-api-của-neovim"></a>Tìm hiểu API của Neovim</h2>
<p>Neovim đã có sẵn terminal emulator built in, đó là lệnh <code>:terminal</code>, khi chạy lệnh này, cửa sổ hiện tại sẽ được thay thế bằng một terminal buffer. Vậy, ý tưởng sẽ là: Tạo một cửa sổ mới, làm cho nó float ở giữa màn hình và chạy lệnh <code>:terminal</code> trong đó.</p>
<p>Theo như <a href="https://neovim.io/doc/user/api.html#api-floatwin">document về floating windows</a> để tạo một floating window, chúng ta cần hai thứ: <strong>1) một buffer</strong> và <strong>2) gọi hàm <code>nvim_open_win()</code> trên buffer đó</strong>.</p>
<p>Để tạo mới một buffer, ta có thể dùng hàm <code>nvim_create_buf()</code>. Kết hợp hai hàm
này với nhau như thế này:</p>
<pre><code>let buf = nvim_create_buf(v:false, v:true)
let opts = {
  \ 'relative': 'cursor',
  \ 'width': 10, 'height': 2,
  \ 'col': 0, 'row': 1,
  \ 'anchor': 'NW',
  \ 'style': 'minimal'
  \ }
let win = nvim_open_win(buf, 0, opts)
</code></pre>
<p>Nói qua về đối tượng <code>opts</code>, đây là các thông số thiết lập cho cửa sổ sẽ được tạo, có mấy thông số cần nói tới như là:</p>
<ul>
<li><code>relative</code>: cho biết cửa sổ mới sẽ có tọa độ dựa trên đối tượng nào, nếu là <code>editor</code> thì tọa độ sẽ dựa trên toàn bộ màn hình Vim, là <code>win</code> thì tọa độ sẽ dựa trên split window hiện hành, là <code>cursor</code> thì tọa độ sẽ dựa trên vị trí con trỏ hiện tại (dùng trong trường hợp làm autocomplete chẳng hạn).</li>
<li><code>style</code>: hiện chỉ nhận 1 giá trị là <code>minimal</code>, nếu truyền giá trị này thì các thành phần như line number, cursor line,... sẽ được ẩn đi hết.</li>
<li>Mấy thông số như <code>width</code>, <code>height</code> chắc khỏi cần nói tới.</li>
<li>Còn <code>col</code> và <code>row</code> là để chỉ định tọa độ ban đầu của cửa sổ.</li>
</ul>
<p>Cả hai hàm <code>nvim_create_buf()</code> và <code>nvim_open_win()</code> đều trả về id của buffer /
floating window vừa tạo ra, chúng ta sẽ dùng các id này khi cần thực hiện các
thao tác thiết lập khác.</p>
<h2><a href="#first-implementation" aria-hidden="true" class="anchor" id="first-implementation"></a>First implementation</h2>
<p>Như vậy, chúng ta đã biết cần phải sử dụng những hàm nào trong API của Neovim để
có thể implement chức năng floating terminal. Cụ thể các bước cần thực hiện là:</p>
<ol>
<li>Tạo một buffer mới</li>
<li>Tạo floating window từ buffer này</li>
<li>Khởi động terminal emulator trên buffer vừa tạo với lệnh <code>:terminal</code></li>
</ol>
<p>Ngoài ra, chúng ta muốn cửa sổ được tạo ra phải nằm chính giữa màn hình, trong
trường hợp này, Neovim có hai biến <code>&amp;lines</code> và <code>&amp;columns</code> cho chúng ta biết kích
thước của toàn bộ màn hình Neovim là bao nhiêu, để có thể tính toán ra các giá
trị <code>width</code>, <code>height</code>, <code>row</code> và <code>col</code> thích hợp.</p>
<p><img src="img/vim-float-term/layout.png" alt="" /></p>
<p>Mặc định, sau khi khởi tạo terminal trong một buffer, thì buffer đó vẫn còn
trong chế độ Normal Mode, để tiện hơn chúng ta có thể dùng lệnh <code>startinsert</code>,
đưa buffer đó vào chế độ Insert Mode luôn.</p>
<p>Implement như sau (chắc không nói thì các bạn cũng biết là chúng ta đang gõ vào
file <code>init.vim</code>):</p>
<pre><code>function! OpenFloatTerm()
  let height = float2nr((&amp;lines - 2) / 1.5)
  let row = float2nr((&amp;lines - height) / 2)
  let width = float2nr(&amp;columns / 1.5)
  let col = float2nr((&amp;columns - width) / 2)
  let opts = {
    \ 'relative': 'editor',
    \ 'row': row,
    \ 'col': col,
    \ 'width': width,
    \ 'height': height,
    \ 'style': 'minimal'
    \ }
  let buf = nvim_create_buf(v:false, v:true)
  let win = nvim_open_win(buf, v:true, opts)
  terminal
  startinsert
endfunction
</code></pre>
<p>Xong rồi, giờ reload Neovim và chạy thử, kết quả sẽ như hình:</p>
<pre><code>:so % | call OpenFloatTerm()
</code></pre>
<img src="img/vim-float-term/first-implementation.png" style="max-width: 750px; margin-left: -100px" />
<p>Trông cũng xịn phết! Nhưng mà hơi xấu một tí.</p>
<p>Hiện tại thì Neovim chưa hỗ trợ các thành phần như margin, padding hay border
cho floating windows, nên nhìn cái cửa sổ terminal hiện lên chưa đã con mắt cho
lắm.</p>
<p>Trong phần tiếp theo, chúng ta sẽ cùng tìm cách fix.</p>
<h2><a href="#second-implementation-cải-tiến-giao-diện" aria-hidden="true" class="anchor" id="second-implementation-cải-tiến-giao-diện"></a>Second implementation: Cải tiến giao diện</h2>
<p>Có một trick, hơi hacky một tí để giải quyết vấn đề padding đó là tạo một cửa sổ
to hơn nằm bên dưới cửa sổ terminal hiện tại, trông như thế này:</p>
<img src="img/vim-float-term/border-layout.png" style="max-width: 750px; margin-left: -100px" />
<p>Lưu ý, vì Neovim là môi trường text mode, một ô trên màn hình sẽ là một hình chữ
nhật đứng, có tỉ lệ gần như là 1:2, nên việc tính lại tọa độ cũng như kích thước
của cửa sổ làm border cũng sẽ được thực hiện với tỉ lệ 1:2.</p>
<p>Tọa độ của cửa sổ border sẽ nằm về phía trên và bên trái của cửa sổ terminal,
tương tự kích thước của cửa sổ border cũng sẽ dài và cao hơn cửa sổ terminal:</p>
<pre class='math'>$$
\text{column}_\text{ border} = \text{column}_\text{ main} - 2 \\
\text{row}_\text{ border} = \text{row}_\text{ main} - 1 \\
\\
\text{width}_\text{ border} = \text{width}_\text{ main} + 4 \\
\text{height}_\text{ border} = \text{height}_\text{ main} + 2
$$</pre>
<p>Hàm <code>OpenFloatTerm()</code> bây giờ sẽ có 2 bước:</p>
<pre><code>function! OpenFloatTerm()
  let height = float2nr((&amp;lines - 2) / 1.5)
  let row = float2nr((&amp;lines - height) / 2)
  let width = float2nr(&amp;columns / 1.5)
  let col = float2nr((&amp;columns - width) / 2)
  &quot; Border Window
  let border_opts = {
    \ 'relative': 'editor',
    \ 'row': row - 1,
    \ 'col': col - 2,
    \ 'width': width + 4,
    \ 'height': height + 2,
    \ 'style': 'minimal'
    \ }
  let border_buf = nvim_create_buf(v:false, v:true)
  let border_win = nvim_open_win(border_buf, v:true, border_opts)
  &quot; Main Window
  let opts = {
    \ 'relative': 'editor',
    \ 'row': row,
    \ 'col': col,
    \ 'width': width,
    \ 'height': height,
    \ 'style': 'minimal'
    \ }
  let buf = nvim_create_buf(v:false, v:true)
  let win = nvim_open_win(buf, v:true, opts)
  terminal
  startinsert
endfunction
</code></pre>
<p>Giờ chạy thử xem:</p>
<img src="img/vim-float-term/border-bug.gif" style="max-width: 750px; margin-left: -100px" />
<p>Trông có vẻ thuận con mắt hơn tí rồi. Nhưng mà chúng ta lại gặp bug! Khi đóng
cửa sổ terminal thì cửa sổ border nó vẫn còn nằm yên không chịu biến mất.</p>
<p>Nguyên nhân thì rõ ràng, chúng ta chỉ tương tác với cửa sổ terminal mà không làm
gì cửa sổ border hết. Để giải quyết vấn đề này, chúng ta có hàm <code>nvim_close_win()</code>, dùng để đóng một
cửa sổ bất kì, ta có thể gọi hàm này khi cửa sổ terminal bị đóng.</p>
<p>Làm sao để biết khi nào cửa sổ terminal bị đóng?</p>
<p>Lại tra tài liệu, chúng ta sẽ thấy <a href="https://neovim.io/doc/user/autocmd.html#TermClose">sự kiện TermClose</a> được gọi khi chúng ta rời khỏi chế độ Terminal. Để bắt sự kiện này, ta dùng lệnh <code>autocmd</code>, như thế này:</p>
<pre><code>autocmd TermClose * ++once :q | call nvim_win_close(&lt;window-id&gt;, v:true)
</code></pre>
<p>Tham số <code>*</code> ở đây có nghĩa là lệnh áp dụng cho mọi buffer, tham số <code>++once</code> sẽ làm cho lệnh này chỉ thực thi 1 lần. Đồng thời, khi terminal bị tắt, Neovim sẽ không đóng buffer chứa terminal đó đi, mà hiện dòng chữ <code>[Process exited 0]</code>, chúng ta phải gửi thêm lệnh <code>:q</code> để đóng nó.</p>
<p>Đây là implementation hoàn chỉnh:</p>
<pre><code>function! OpenFloatTerm()
  let height = float2nr((&amp;lines - 2) / 1.5)
  let row = float2nr((&amp;lines - height) / 2)
  let width = float2nr(&amp;columns / 1.5)
  let col = float2nr((&amp;columns - width) / 2)
  &quot; Border Window
  let border_opts = {
    \ 'relative': 'editor',
    \ 'row': row - 1,
    \ 'col': col - 2,
    \ 'width': width + 4,
    \ 'height': height + 2,
    \ 'style': 'minimal'
    \ }
  let border_buf = nvim_create_buf(v:false, v:true)
  let s:border_win = nvim_open_win(border_buf, v:true, border_opts)
  &quot; Main Window
  let opts = {
    \ 'relative': 'editor',
    \ 'row': row,
    \ 'col': col,
    \ 'width': width,
    \ 'height': height,
    \ 'style': 'minimal'
    \ }
  let buf = nvim_create_buf(v:false, v:true)
  let win = nvim_open_win(buf, v:true, opts)
  terminal
  startinsert
  &quot; Hook up TermClose event to close both terminal and border windows
  autocmd TermClose * ++once :q | call nvim_win_close(s:border_win, v:true)
endfunction
</code></pre>
<p>Và đây là thành phẩm:</p>
<img src="img/vim-float-term/final.gif" style="max-width: 750px; margin-left: -100px" />
<hr />
<p>Hy vọng qua bài viết này, các bạn sẽ hiểu được phần nào chức năng Floating
Windows của Neovim, cũng như những ứng dụng mà nó mang lại. Từ đầu tới giờ viết
dông dài vậy thôi chứ nếu bạn chỉ xài Vim như là một user bình thường thì không
cần đọc bài này đâu.</p>
<p>Thế nhé. Tổng chào <i class='em em-smirk'></i></p>
<div class='other-tags'><b>Tags:</b> <a class='topic-tag' href='../tags/vim.html'>vim</a></div>
<div class="related-posts" style="margin-top: 15px; border-bottom: 1px solid #eee;">
<p><i class="em em-sun_with_face"></i> Cảm ơn bạn đã theo dõi bài viết! các bạn có thể <a href="https://facebook.com/thefullsnackblog" target="_blank">follow mình trên Facebook</a> để đặt câu hỏi, hoặc nhận thông tin về các bài viết mới.</p>
</div>
<div class="comments">
<ul id="comment-list" class="comment-list"></ul>
<div id="login-box" class="login">
Bạn nghĩ như thế nào về bài viết này?<br /><button onclick="login()">Tham gia bình luận</button>
<div class="copyright">Chức năng này cần liên kết với tài khoản Google<br />Nếu không thích thì có thể comment <button onclick="goninja()">Nặc danh</button></div>
</div>
<div id="comment-box" class="comment-input">
<div class="avatar">
<img id="user-avatar" src="#" width="32" height="32" />
</div>
<div class="input">
<textarea id="comment-content" onkeydown="submitComment(event)" placeholder="Comment gõ vào đây :D"></textarea>
<span>Gõ xong nhấn <kbd>Ctrl</kbd> + <kbd>Enter</kbd> để gửi. Bạn không thể xóa comment sau khi gửi.</span>
<button id="comment-button" onclick="submitData()">Gửi</button>
</div>
</div>
</div>
</div>
</div>
<div class="footer lightweight-theme">
<p>you're free to use the content on this blog for whatever you want</p>
<p>Created with <i class="em em-coffee"></i> <a href="https://github.com/huytd/ristretto-rs">ristretto.rs</a></p>
</div>
<script src="../js/highlight.pack.js"></script>
<script>
        </script>
<script type="text/javascript" async src="../../cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJaxb198.js?config=TeX-MML-AM_CHTML"></script>
<script type="text/x-mathjax-config">
         MathJax.Hub.Config({
             tex2jax: {
                 inlineMath: [['$','$'], ['\\(','\\)']],
                 skipTags: ["script","noscript","style","textarea", "code"],
                 ignoreClass: "tex2jax_ignore|comment|comment-list|content"
             }
         });
        </script>
<script src="../js/toc.js"></script>
<script src="../../www.gstatic.com/firebasejs/3.8.0/firebase.js"></script>
<script>
         let postCommentURL = '../api/post/vim-play-with-floating.json';
         // Initialize Firebase
         var config = {
             apiKey: "AIzaSyA1PnIAlJJ-U6iQJMNnCOknBuziBqGMYcY",
             authDomain: "huys-blog-comment.firebaseapp.com",
             databaseURL: "https://huys-blog-comment.firebaseio.com",
             projectId: "huys-blog-comment",
             storageBucket: "huys-blog-comment.appspot.com",
             messagingSenderId: "317330376829"
         };

         var login = function() {
             window.auth.signInWithPopup(provider)
                   .then(function(result) {
                   }).catch(function(err) {
                   });
         };

         var goninja = function() {
             updateAuth({
                 displayName: "Không Tên",
                 photoURL: "https://thefullsnack.com/img/kaonashi.jpg"
             });
         };

         var updateAuth = function(user) {
             if (user) {
                 currentUser = user;
                 // Logged in
                 document.getElementById("login-box").style.display = "none";
                 document.getElementById("comment-box").style.display = "flex";
                 document.getElementById("user-avatar").setAttribute("src", user.photoURL + "?sz=32");
             } else {
                 // Not login yet
                 document.getElementById("comment-box").style.display = "none";
                 document.getElementById("login-box").style.display = "block";
             }
         };

         var encodeHTML = function(s) {
             return s.replace(/</g, '&lt;').replace(/"/g, '&quot;').replace(/>/g, '&gt;');
         };

         var saveNewComment = function(comment) {
             if (!currentUser) {
                 return;
             }
             var commentData = {
                 username: currentUser.displayName,
                 avatar: currentUser.photoURL,
                 post_time: ~~((new Date()).getTime() / 1000),
                 message: encodeHTML(comment)
             };

             fetch(postCommentURL, {
                 method: 'post',
                 headers: {
                     "Content-Type": "application/json"
                 },
                 body: JSON.stringify(commentData)
             }).then((result) => {
                 if (result.status === 200) {
                     addNewComment(commentData.username, commentData.avatar, commentData.post_time, commentData.message);
                 }
             });

             document.getElementById("comment-content").value = "";
         };

         function debounce(func, wait, immediate) {
             var timeout;
             return function() {
                 var context = this, args = arguments;
                 var later = function() {
                     timeout = null;
                     if (!immediate) func.apply(context, args);
                 };
                 var callNow = immediate && !timeout;
                 clearTimeout(timeout);
                 timeout = setTimeout(later, wait);
                 if (callNow) func.apply(context, args);
             };
         };

         var submitData = debounce(function() {
             var comment = document.getElementById("comment-content").value;
             if (comment.length) {
                 saveNewComment(comment);
             }
         }, 250);

         var submitComment = function(e) {
             var keyCode = e.which || e.keyCode;
             var ctrlCode = e.ctrlKey || e.metaKey;
             if (keyCode === 13 && ctrlCode) {
                 submitData();
             }
         };

         var filterNewlineInComment = function(t) {
             return t.replace(/\n/g, "<br/>");
         };

         var filterURLinComment = function(comment) {
             return comment.replace(/(https?:\/\/(?:www\.|(?!www))[a-zA-Z0-9][a-zA-Z0-9-]+[a-zA-Z0-9]\.[^\s]{2,}|www\.[a-zA-Z0-9][a-zA-Z0-9-]+[a-zA-Z0-9]\.[^\s]{2,}|https?:\/\/(?:www\.|(?!www))[a-zA-Z0-9]\.[^\s]{2,}|www\.[a-zA-Z0-9]\.[^\s]{2,})/g, "<a target='_blank' rel='noopener noreferrer' href='$1'>$1</a>");
         };

         var addNewComment = function(user, avatar, time, comment, first) {
             var commentFiltered = encodeHTML(comment);
             commentFiltered = filterNewlineInComment(filterURLinComment(commentFiltered));
             commentFiltered = commentFiltered.replace(/```/g, '');
             var d = new Date(time * 1000);
             var commentTime = d.toLocaleTimeString() + ' ' + d.toLocaleDateString();
             var anoNameClass = (avatar.indexOf('thefullsnack.com') !== -1) ? "grey" : "";
             var html = '<div class="avatar">' +
                        '   <img src="' + avatar + '?sz=32" width="32" height="32"/>' +
                        ' </div>' +
                        '<div class="comment">' +
                        '  <div class="metadata"><b class="' + anoNameClass + '">' + encodeHTML(user) + '</b> lúc <span>' + commentTime + '</span></div>' +
                        '  <div class="content tex2jax_ignore">' + commentFiltered
             '  </div>' +
                        '</div>';
             var li = document.createElement('li');
             li.innerHTML = html;
             if (!first) {
                 document.getElementById("comment-list").append(li);
             } else {
                 let elm = document.getElementById("comment-list");
                 elm.insertBefore(li, elm.firstChild);
             }
         };



         window.onload = function() {

             document.querySelectorAll("pre code").forEach(el => {
                 hljs.highlightBlock(el);
             });

             start_toc_module();

             firebase.initializeApp(config);
             window.provider = new firebase.auth.GoogleAuthProvider();
             window.auth = firebase.auth();
             window.currentUser = null;

             window.auth.onAuthStateChanged(function(user) {
                 updateAuth(user);
             });


             // Fetch comment and put to posts
             fetch(postCommentURL)
                 .then(res => res.json())
                 .then(data => {
                     if (data.comments) {
                         let comments = data.comments;
                         comments.sort((a, b) => a.post_time - b.post_time);
                         for (let i = 0; i < comments.length; i++) {
                             let cmt = comments[i];
                             addNewComment(cmt.username, cmt.avatar, cmt.post_time, cmt.message);
                         }
                     }
                 });
         };

         var toggle_wordwise = function(status) {
             var book = document.querySelector("book");
             var on = document.querySelector("#ww_on");
             var off = document.querySelector("#ww_off");
             if (!status) {
                 book.className = "off";
                 on.className = "btn-toggle";
                 off.className = "btn-toggle active";
             } else {
                 book.className = "";
                 on.className = "btn-toggle active";
                 off.className = "btn-toggle";
             }
         };
        </script>
</body>

<!-- Mirrored from thefullsnack.com/posts/vim-play-with-floating.html by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 12 May 2020 03:19:01 GMT -->
</html>
