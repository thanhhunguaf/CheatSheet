<html>

<!-- Mirrored from thefullsnack.com/posts/frontend-algorithm-002.html by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 12 May 2020 03:20:00 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf8" /><!-- /Added by HTTrack -->
<head>
<title>Algorithm in Frontend - Kỳ 2: Tree và Menu | Huy's Blog</title>
<meta charset="utf-8">
<meta http-equiv="content-type" content="text/html;"><meta name=viewport content="initial-scale=1.0 maximum-scale=1.0">
<meta property='og:image' content='img/c-programmer.png'>
<link rel="apple-touch-icon" sizes="180x180" href="../apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="../favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="../favicon-16x16.png">
<link rel="manifest" href="../manifest.json">
<link rel="mask-icon" href="../safari-pinned-tab.svg" color="#5bbad5">
<meta name="theme-color" content="#ffffff">
<link href="../css/theme.dist.css" rel="stylesheet" type="text/css">
<link rel="stylesheet" href="../emoji/css/emoji.dist.css">
<link href="https://fonts.googleapis.com/css?family=Open+Sans:400,700|Space+Mono:400,700&amp;display=swap&amp;subset=vietnamese" rel="stylesheet">

<script async src="https://www.googletagmanager.com/gtag/js?id=UA-92158965-1"></script>
<script>
	       window.dataLayer = window.dataLayer || [];
	       function gtag(){dataLayer.push(arguments);}
	       gtag('js', new Date());

	       gtag('config', 'UA-92158965-1');
	      </script>
</head>
<body lang="en" class="post">
<div class="header lightweight-theme">
<a href="../index.html"><span class="avatar"></span></a>
</div>
<div class="container">
<div class="main">
<h1><span>Algorithm in Frontend - Kỳ 2: Tree và Menu</span></h1>
<p>Tiếp tục với sê ri <a href="frontend-algorithm-001.html">Algorithm in Frontend</a>, kì này nói về một loại cấu trúc dữ liệu được dùng thường xuyên trên frontend, đó là <strong>Kiểu dữ liệu dạng cây (tree)</strong>.</p>
<p>Nhắc đến cây thì hẳn chúng ta nghĩ ngay đến DOM và các thao tác trên đó, ví dụ như tìm kiếm một element trên DOM, thêm/xóa element,... tuy nhiên các thao tác này chúng ta thường sử dụng DOM API có sẵn của trình duyệt và bài này cũng không có ý định nói đến phần đó <i class='em em-laughing'></i></p>
<h2><a href="#bài-toán-cần-giải-quyết" aria-hidden="true" class="anchor" id="bài-toán-cần-giải-quyết"></a>Bài toán cần giải quyết</h2>
<p>Thực ra đây là một câu hỏi phỏng vấn cho vị trí Frontend Engineer tại công ty <strong>G</strong> cũng khá là có tiếng tăm (vì họ bắt mình ký NDA không được tiết lộ nội dung buôi phỏng vấn, nhưng mà để viết bài này thì phải lộ đề rồi, nên thôi mình không tiết lộ tên công ty đó vậy <i class='em em-grin'></i> hình như đây là lần thứ 2 mình nhắc đến NDA rồi, mấy cái công ty cứ thích dùng cái này để bịt miệng người ta quài).</p>
<p>Đề bài như này. Cho một cục dữ liệu JSON có dạng:</p>
<p><strong>menu.json</strong></p>
<pre><code class="language-json">[
  {
    &quot;name&quot;: &quot;Electronics&quot;,
    &quot;items&quot;: [&quot;Laptop&quot;, &quot;Headphones&quot;]
  },
  {
    &quot;name&quot;: &quot;Headphones&quot;,
    &quot;items&quot;: [&quot;Shure&quot;, &quot;Bose&quot;, &quot;JLB&quot;]
  },
  {
    &quot;name&quot;: &quot;Cars&quot;,
    &quot;items&quot;: [&quot;SUV&quot;, &quot;Sedan&quot;, &quot;Sports&quot;]
  },
  {
    &quot;name&quot;: &quot;SUV&quot;,
    &quot;items&quot;: [&quot;Honda&quot;, &quot;Ferrari&quot;]
  },
  {
    &quot;name&quot;: &quot;Laptop&quot;,
    &quot;items&quot;: [&quot;Thinkpad&quot;]
  }
]
</code></pre>
<p>Hãy xây dựng một component in ra một menu đa cấp (multi-level menu) dựa trên dữ liệu đã cho. Đối với dữ liệu mẫu ở trên thì cấu trúc của menu sẽ là:</p>
<pre><code class="language-text">  |- Electronics
  |    |- Headphones
  |    |   |- Shure
  |    |   |- Bose
  |    |   |- JLB
  |    |- Laptop
  |    |   |- Thinkpad
  |- Cars
  |    |- SUV
  |    |   |- Honda
  |    |   |- Ferrari
  |    |- Sedan
  |    |- Sports
</code></pre>
<p>Câu hỏi này gây ấn tượng mạnh với mình vì lúc đó là lần đầu tiên mình gặp một câu hỏi phỏng vấn núp bóng dưới dạng một ứng dụng thực tiễn rõ ràng như thế này.</p>
<h2><a href="#phân-tích-đề-bài" aria-hidden="true" class="anchor" id="phân-tích-đề-bài"></a>Phân tích đề bài</h2>
<p>Mặc dù đề bài yêu cầu <em>xây dựng một component in ra một menu đa cấp</em>, nhưng bản chất bài toán vẫn là <strong>xây dựng thuật toán chuyển cục JSON kia về dạng cây</strong>.</p>
<p><em>Nói thì dễ, đến lúc vào phỏng vấn thì mặt mình tái mét, dành hết 40 phút để implement cái cơ chế tạo và mount một custom component theo kiểu Angular Directive, trong khi không đả động gì đến cái đề bài, kết quả là fail dập mặt <i class='em em-sweat'></i></em></p>
<p>Nhìn vào dữ liệu input (tạm gọi là $I$) ta có thể thấy đây là một mảng &quot;phẳng&quot; (flat array), và mỗi phần tử của mảng này có thể có hoặc không có mối liên hệ nào với nhau. Nếu một phần tử $I_j$ là &quot;con&quot; của $I_i$ thì tên $I_j\texttt{.name}$ sẽ có mặt trong mảng $I_i\texttt{.items}$.</p>
<p>Nhiệm vụ của chúng ta sẽ biến mảng phẳng này thành một cây dữ liệu, dựa trên mối quan hệ vừa đề cập.</p>
<h2><a href="#cấu-trúc-dữ-liệu" aria-hidden="true" class="anchor" id="cấu-trúc-dữ-liệu"></a>Cấu trúc dữ liệu</h2>
<p>OK, vậy thì đầu tiên ta phải nghĩ về cấu trúc dữ liệu của một Node trên cây, sẽ có dạng như sau:</p>
<p><strong>pseudo code</strong></p>
<pre><code class="language-javascript">struct Node {
  name: String,
  items: Array&lt;Node&gt;
}
</code></pre>
<p>Với cấu trúc trên, một Node cha sẽ có các Node con nằm trong trường <code>items</code>, và với một Node lá, không có Node con nào, thì trường <code>items</code> chỉ là một mảng rỗng.</p>
<p>Như vậy, nếu $\texttt{Thinkpad}$ là một Node lá, và cũng là con của $\texttt{Laptop}$ thì cây của chúng ta sẽ có dạng:</p>
<pre><code class="language-javascript">Node {
  name: &quot;Laptop&quot;,
  items: [
    Node {
      name: &quot;Thinkpad&quot;,
      items: []
    }
  ]
}
</code></pre>
<h2><a href="#xây-dựng-thuật-toán" aria-hidden="true" class="anchor" id="xây-dựng-thuật-toán"></a>Xây dựng thuật toán</h2>
<p>Ý tưởng của thuật toán sẽ gồm 2 công đoạn, giống như chơi xếp hình vậy:</p>
<ul>
<li><strong>Màn dạo đầu:</strong> để thống nhất về kiểu dữ liệu, ta đưa mảng input $I$ thành một mảng có mỗi phần tử là một cây riêng biệt, có gốc (root) chính là phần tử $I_i$ đang xét, và các node lá là các phần tử của $I_i\texttt{.items}$.</li>
<li><strong>Xếp hình:</strong> gọi là lắp ráp thì đúng hơn, ở bước này ta sẽ ráp nối các cây lại với nhau theo kiểu, cây nào con cây nào thì cắm vào cây đó. Kết thúc việc lắp ráp thì chúng ta sẽ có một cây hoàn chỉnh như đề bài yêu cầu.</li>
</ul>
<p>Thuật toán đầy đủ được mô tả như sau:</p>
<ul>
<li><strong>Bước 1:</strong> Duyệt qua tất cả các phần tử của mảng $I$</li>
<li><strong>Bước 2:</strong> Với mỗi phần tử $I_i$ (còn gọi là một cây $I_i$), duyệt qua tất cả các phần tử của mảng $I_i\texttt{.items}$ (các cây con của $I_i$).</li>
<li><strong>Bước 3:</strong> Gọi $\texttt{node}$ là phần tử $I_i\texttt{.items}_j$ đang xét. Tìm trong mảng $I$ một phần tử $I_t$ sao cho $I_t\texttt{.name} == \texttt{node}$.</li>
<li><strong>Bước 3a:</strong> Nếu tìm thấy một phần tử $I_t$ thỏa điều kiện trên thì thay thế $\texttt{node}$ thành $I_t$. Đánh dấu $I_t$ thành một cây cần xóa.</li>
<li><strong>Bước 3b:</strong> Nếu không thì biến $\texttt{node}$ thành một lá của cây $I_i$</li>
<li><strong>Bước 4:</strong> Xóa tất cả các cây $I_i$ đã được đánh dấu trong mảng $I$. Mảng thu được chính là mảng kết quả.</li>
</ul>
<p>Khác với các ngôn ngữ lập trình khác, vì JavaScript là dynamic typing, ta có thể dễ dàng thay đổi giữa nhiều kiểu dữ liệu cho một biến, chính vì thế, rất có khả năng bạn sẽ bị confuse khi đọc đến bước <strong>3</strong> và <strong>3a</strong> :see_no_evil:</p>
<p>Ở bước <strong>3</strong>, một giá trị $\texttt{node} = I_i\texttt{.items}_j$ sẽ mang kiểu <code>string</code>, đến bước <strong>3a</strong> ta lại gán $\texttt{node}$ thành một giá trị $I_t$ (là một cây).</p>
<p>Nếu ngôn ngữ mà các bạn sử dụng không phải JavaScript mà là một ngôn ngữ strong typing nào đó ví dụ như Go hay Rust hay C/C++, thì thuật toán ở trên cần phải được sửa lại.</p>
<p>Còn bây giờ thì implement thôi:</p>
<pre><code>const buildTree = (nodes) =&gt; {
  for (let i = 0; i &lt; nodes.length; i++) {
    for (let j = 0; j &lt; nodes[i].items.length; j++) {
      let node = nodes[i].items[j];
      let found = nodes.find(n =&gt; n.name == node);
      if (found) {
        nodes[i].items[j] = Object.assign({}, found);
        found.removed = true;
      } else {
        nodes[i].items[j] = {
          name: node,
          items: []
        };
      }
    }
  }

  return nodes.reduce((arr, item) =&gt; {
    if (!item.removed) {
      arr.push(item);
    }
    return arr;
  }, []);
}
</code></pre>
<p>Chúng ta chạy thử và in kết quả dưới dạng một chuỗi JSON để thấy rõ cấu trúc dạng cây:</p>
<pre><code>let list = require('./menu.json');
let result = buildTree(list);
console.log(JSON.stringify(result, null, '  '));
</code></pre>
<details>
<summary>Nội dung JSON của kết quả thu được</summary>
<pre><code class="hljs javascript">[
  {
    "name": "Cars",
    "items": [
      {
        "name": "SUV",
        "items": [
          {
            "name": "Honda",
            "items": []
          },
          {
            "name": "Ferrari",
            "items": []
          }
        ]
      },
      {
        "name": "Sedan",
        "items": []
      },
      {
        "name": "Sports",
        "items": []
      }
    ]
  },
  {
    "name": "Electronics",
    "items": [
      {
        "name": "Laptop",
        "items": [
          {
            "name": "Thinkpad",
            "items": []
          }
        ]
      },
      {
        "name": "Headphones",
        "items": [
          {
            "name": "Shure",
            "items": []
          },
          {
            "name": "Bose",
            "items": []
          },
          {
            "name": "JLB",
            "items": []
          }
        ]
      }
    ]
  }
]
</code>
</pre>
</details>
<h2><a href="#phức-tạp-quá-làm-vậy-chi-cho-cực?" aria-hidden="true" class="anchor" id="phức-tạp-quá-làm-vậy-chi-cho-cực?"></a>Phức tạp quá, làm vậy chi cho cực?</h2>
<p>Đọc đến đây hẳn có bạn sẽ đặt ra câu hỏi: Tại sao ngay từ ban đầu lại dùng kiểu dữ liệu dạng như thế này trên frontend? Chẳng phải đây là việc của backend hay sao? Trên thực tế có ai làm vậy không?</p>
<p>Câu trả lời nằm ở tính tiện lợi khi cần mở rộng menu dạng cây như thế này, ví dụ, với mảng $I$ đã cho ở trên, khi chúng ta cần mở rộng, ví dụ thêm vào một loại laptop khác bên cạnh dòng <strong>Thinkpad</strong>, hoặc thêm vào một hãng xe ô tô mới, ta có thể thêm trực tiếp một hoặc nhiều item mới vào mảng $I$, ví dụ:</p>
<p><strong>menu.json</strong></p>
<pre><code class="language-javascript">[
  ...,
  {
    &quot;name&quot;: &quot;Laptop&quot;,
    &quot;items&quot;: [&quot;Thinkpad&quot;]
  },
  {
    &quot;name&quot;: &quot;Thinkpad&quot;,
    &quot;items&quot;: [&quot;X220&quot;, &quot;T450&quot;]
  },
  {
    &quot;name&quot;: &quot;X220&quot;,
    &quot;items&quot;: [&quot;New&quot;, &quot;Second Hand&quot;]
  },
  ...
]
</code></pre>
<p>Nếu lưu dữ liệu trực tiếp dạng cây thì việc cả việc lưu trữ lẫn việc thêm/bớt này quả thực là một vấn đề không đơn giản. Hay nói cách khác thì giải pháp đó không scalable.</p>
<h2><a href="#bài-viết-này-có-giúp-tôi-được-tăng-lương-không" aria-hidden="true" class="anchor" id="bài-viết-này-có-giúp-tôi-được-tăng-lương-không"></a>Bài viết này có giúp tôi được tăng lương không?</h2>
<p><strong>Lưu ý:</strong> Bản quyền câu nói trên thuộc về blog <a href="https://quan-cam.com/">Quần Cam</a>, để đưa câu nói này vào bài viết, mình đã phải trả một khoản &quot;tiền&quot; khá lớn, mong các bạn đừng bắt chước.</p>
<p>Chân thành mà nói thì việc tăng lương hay không phụ thuộc vào... sếp của bạn <i class='em em-joy'></i></p>
<p>Tuy nhiên, là một frontend developer, bạn cũng là một phần rất quan trọng trong team, nếu phải lựa chọn giữa một giải pháp <strong>tiện lợi cho cá nhân mình nhưng sẽ tạo ra gánh nặng cho phần còn lại của team</strong>, và một giải pháp <strong>tạo ra vài thách thức nhỏ cho bản thân nhưng đem lại hiệu quả cho toàn bộ hệ thống</strong>, thì có lẽ hy sinh một chút thời gian và sự thoải mái của bản thân sẽ tốt hơn so với việc ngồi câu nệ xem việc này là của ai và ai phải làm gì.</p>
<p>Rất cảm ơn các bạn đã đọc đến tận dòng này, hy vọng các bạn thích sê ri này, đừng ngại để lại comment nếu các bạn có bất kỳ góp ý hay gợi ý gì. Hẹn gặp lại các bạn trong các bài viết sắp tới.</p>
<div class='other-tags'><b>Tags:</b> <a class='topic-tag' href='../tags/code.html'>code</a><a class='topic-tag' href='../tags/frontend.html'>frontend</a><a class='topic-tag' href='../tags/algorithm.html'>algorithm</a></div>
<div class="related-posts" style="margin-top: 15px; border-bottom: 1px solid #eee;">
<p><i class="em em-sun_with_face"></i> Cảm ơn bạn đã theo dõi bài viết! các bạn có thể <a href="https://facebook.com/thefullsnackblog" target="_blank">follow mình trên Facebook</a> để đặt câu hỏi, hoặc nhận thông tin về các bài viết mới.</p>
</div>
<div class="comments">
<ul id="comment-list" class="comment-list"></ul>
<div id="login-box" class="login">
Bạn nghĩ như thế nào về bài viết này?<br /><button onclick="login()">Tham gia bình luận</button>
<div class="copyright">Chức năng này cần liên kết với tài khoản Google<br />Nếu không thích thì có thể comment <button onclick="goninja()">Nặc danh</button></div>
</div>
<div id="comment-box" class="comment-input">
<div class="avatar">
<img id="user-avatar" src="#" width="32" height="32" />
</div>
<div class="input">
<textarea id="comment-content" onkeydown="submitComment(event)" placeholder="Comment gõ vào đây :D"></textarea>
<span>Gõ xong nhấn <kbd>Ctrl</kbd> + <kbd>Enter</kbd> để gửi. Bạn không thể xóa comment sau khi gửi.</span>
 <button id="comment-button" onclick="submitData()">Gửi</button>
</div>
</div>
</div>
</div>
</div>
<div class="footer lightweight-theme">
<p>you're free to use the content on this blog for whatever you want</p>
<p>Created with <i class="em em-coffee"></i> <a href="https://github.com/huytd/ristretto-rs">ristretto.rs</a></p>
</div>
<script src="../js/highlight.pack.js"></script>
<script>
        </script>
<script type="text/javascript" async src="../../cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJaxb198.js?config=TeX-MML-AM_CHTML"></script>
<script type="text/x-mathjax-config">
         MathJax.Hub.Config({
             tex2jax: {
                 inlineMath: [['$','$'], ['\\(','\\)']],
                 skipTags: ["script","noscript","style","textarea", "code"],
                 ignoreClass: "tex2jax_ignore|comment|comment-list|content"
             }
         });
        </script>
<script src="../js/toc.js"></script>
<script src="../../www.gstatic.com/firebasejs/3.8.0/firebase.js"></script>
<script>
         let postCommentURL = '../api/post/frontend-algorithm-002.json';
         // Initialize Firebase
         var config = {
             apiKey: "AIzaSyA1PnIAlJJ-U6iQJMNnCOknBuziBqGMYcY",
             authDomain: "huys-blog-comment.firebaseapp.com",
             databaseURL: "https://huys-blog-comment.firebaseio.com",
             projectId: "huys-blog-comment",
             storageBucket: "huys-blog-comment.appspot.com",
             messagingSenderId: "317330376829"
         };

         var login = function() {
             window.auth.signInWithPopup(provider)
                   .then(function(result) {
                   }).catch(function(err) {
                   });
         };

         var goninja = function() {
             updateAuth({
                 displayName: "Không Tên",
                 photoURL: "https://thefullsnack.com/img/kaonashi.jpg"
             });
         };

         var updateAuth = function(user) {
             if (user) {
                 currentUser = user;
                 // Logged in
                 document.getElementById("login-box").style.display = "none";
                 document.getElementById("comment-box").style.display = "flex";
                 document.getElementById("user-avatar").setAttribute("src", user.photoURL + "?sz=32");
             } else {
                 // Not login yet
                 document.getElementById("comment-box").style.display = "none";
                 document.getElementById("login-box").style.display = "block";
             }
         };

         var encodeHTML = function(s) {
             return s.replace(/</g, '&lt;').replace(/"/g, '&quot;').replace(/>/g, '&gt;');
         };

         var saveNewComment = function(comment) {
             if (!currentUser) {
                 return;
             }
             var commentData = {
                 username: currentUser.displayName,
                 avatar: currentUser.photoURL,
                 post_time: ~~((new Date()).getTime() / 1000),
                 message: encodeHTML(comment)
             };

             fetch(postCommentURL, {
                 method: 'post',
                 headers: {
                     "Content-Type": "application/json"
                 },
                 body: JSON.stringify(commentData)
             }).then((result) => {
                 if (result.status === 200) {
                     addNewComment(commentData.username, commentData.avatar, commentData.post_time, commentData.message);
                 }
             });

             document.getElementById("comment-content").value = "";
         };

         function debounce(func, wait, immediate) {
             var timeout;
             return function() {
                 var context = this, args = arguments;
                 var later = function() {
                     timeout = null;
                     if (!immediate) func.apply(context, args);
                 };
                 var callNow = immediate && !timeout;
                 clearTimeout(timeout);
                 timeout = setTimeout(later, wait);
                 if (callNow) func.apply(context, args);
             };
         };

         var submitData = debounce(function() {
             var comment = document.getElementById("comment-content").value;
             if (comment.length) {
                 saveNewComment(comment);
             }
         }, 250);

         var submitComment = function(e) {
             var keyCode = e.which || e.keyCode;
             var ctrlCode = e.ctrlKey || e.metaKey;
             if (keyCode === 13 && ctrlCode) {
                 submitData();
             }
         };

         var filterNewlineInComment = function(t) {
             return t.replace(/\n/g, "<br/>");
         };

         var filterURLinComment = function(comment) {
             return comment.replace(/(https?:\/\/(?:www\.|(?!www))[a-zA-Z0-9][a-zA-Z0-9-]+[a-zA-Z0-9]\.[^\s]{2,}|www\.[a-zA-Z0-9][a-zA-Z0-9-]+[a-zA-Z0-9]\.[^\s]{2,}|https?:\/\/(?:www\.|(?!www))[a-zA-Z0-9]\.[^\s]{2,}|www\.[a-zA-Z0-9]\.[^\s]{2,})/g, "<a target='_blank' rel='noopener noreferrer' href='$1'>$1</a>");
         };

         var addNewComment = function(user, avatar, time, comment, first) {
             var commentFiltered = encodeHTML(comment);
             commentFiltered = filterNewlineInComment(filterURLinComment(commentFiltered));
             commentFiltered = commentFiltered.replace(/```/g, '');
             var d = new Date(time * 1000);
             var commentTime = d.toLocaleTimeString() + ' ' + d.toLocaleDateString();
             var anoNameClass = (avatar.indexOf('thefullsnack.com') !== -1) ? "grey" : "";
             var html = '<div class="avatar">' +
                        '   <img src="' + avatar + '?sz=32" width="32" height="32"/>' +
                        ' </div>' +
                        '<div class="comment">' +
                        '  <div class="metadata"><b class="' + anoNameClass + '">' + encodeHTML(user) + '</b> lúc <span>' + commentTime + '</span></div>' +
                        '  <div class="content tex2jax_ignore">' + commentFiltered
             '  </div>' +
                        '</div>';
             var li = document.createElement('li');
             li.innerHTML = html;
             if (!first) {
                 document.getElementById("comment-list").append(li);
             } else {
                 let elm = document.getElementById("comment-list");
                 elm.insertBefore(li, elm.firstChild);
             }
         };



         window.onload = function() {

             document.querySelectorAll("pre code").forEach(el => {
                 hljs.highlightBlock(el);
             });

             start_toc_module();

             firebase.initializeApp(config);
             window.provider = new firebase.auth.GoogleAuthProvider();
             window.auth = firebase.auth();
             window.currentUser = null;

             window.auth.onAuthStateChanged(function(user) {
                 updateAuth(user);
             });


             // Fetch comment and put to posts
             fetch(postCommentURL)
                 .then(res => res.json())
                 .then(data => {
                     if (data.comments) {
                         let comments = data.comments;
                         comments.sort((a, b) => a.post_time - b.post_time);
                         for (let i = 0; i < comments.length; i++) {
                             let cmt = comments[i];
                             addNewComment(cmt.username, cmt.avatar, cmt.post_time, cmt.message);
                         }
                     }
                 });
         };

         var toggle_wordwise = function(status) {
             var book = document.querySelector("book");
             var on = document.querySelector("#ww_on");
             var off = document.querySelector("#ww_off");
             if (!status) {
                 book.className = "off";
                 on.className = "btn-toggle";
                 off.className = "btn-toggle active";
             } else {
                 book.className = "";
                 on.className = "btn-toggle active";
                 off.className = "btn-toggle";
             }
         };
        </script>
</body>

<!-- Mirrored from thefullsnack.com/posts/frontend-algorithm-002.html by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 12 May 2020 03:20:01 GMT -->
</html>
